    // Check if player has enough funds for basic breeding fee
    if (player.funds < this.breedingFees.basic) {
      return { success: false, message: "Insufficient funds for breeding fee" };
    }
    
    // Charge breeding fee
    player.removeFunds(this.breedingFees.basic);
    
    // Calculate breeding success chance
    const baseSuccessChance = 0.7; // 70% base chance
    
    // Adjust based on horse quality and compatibility
    const sireQuality = sire.calculateOverallRating() / 100;
    const damQuality = dam.calculateOverallRating() / 100;
    
    // Compatibility bonus (simplified)
    let compatibilityBonus = 0;
    if (sire.preferredDistance === dam.preferredDistance) compatibilityBonus += 0.05;
    if (sire.preferredSurface === dam.preferredSurface) compatibilityBonus += 0.05;
    
    // Calculate final success chance
    const successChance = baseSuccessChance + (sireQuality * 0.1) + (damQuality * 0.1) + compatibilityBonus + this.seasonalBonus;
    
    // Check if breeding is successful
    if (Math.random() > successChance) {
      return { success: false, message: "Breeding attempt failed", refund: this.breedingFees.basic / 2 };
    }
    
    // Create the offspring (on a delayed timeframe)
    const offspringData = {
      sire: sire,
      dam: dam,
      birthDay: Math.floor(player.gameTime) + this.gestationPeriod,
      traits: this.calculateOffspringTraits(sire, dam)
    };
    
    // Add to pending offspring
    this.pendingOffspring.push(offspringData);
    
    // Put both horses on cooldown
    sire.breedingCooldown = this.breedingCooldown;
    dam.breedingCooldown = this.breedingCooldown;
    
    // Record breeding in log
    this.breedingLog.push({
      date: Date.now(),
      sireId: sire.id,
      damId: dam.id,
      successful: true,
      offspringId: null // Will be updated when born
    });
    
    // Record breeding in player stats
    player.recordHorseBred();
    
    return { 
      success: true, 
      message: "Breeding successful! Foal expected in " + this.gestationPeriod + " days.",
      birthDay: offspringData.birthDay
    };
  }
  
  calculateOffspringTraits(sire, dam) {
    const traits = [];
    
    // Chance to inherit traits from parents
    this.geneticTraits.forEach(trait => {
      // Check if either parent has the trait
      const sireHasTrait = sire.traits && sire.traits.some(t => t.name === trait.name);
      const damHasTrait = dam.traits && dam.traits.some(t => t.name === trait.name);
      
      if (sireHasTrait || damHasTrait) {
        // Chance to inherit is higher if both parents have it
        const inheritChance = (sireHasTrait && damHasTrait) ? 0.8 : 0.5;
        
        if (Math.random() < inheritChance) {
          traits.push({ ...trait });
        }
      } else {
        // Small chance of spontaneous trait
        if (Math.random() < 0.05) {
          traits.push({ ...trait });
        }
      }
    });
    
    return traits;
  }
  
  checkBirthdays(gameTime, player, horseManager) {
    const currentDay = Math.floor(gameTime);
    const newOffspring = [];
    
    // Check for foals ready to be born
    this.pendingOffspring = this.pendingOffspring.filter(offspringData => {
      if (offspringData.birthDay <= currentDay) {
        // Create the new horse
        const offspring = horseManager.breedHorses(offspringData.sire, offspringData.dam);
        
        // Apply traits
        offspring.traits = offspringData.traits;
        
        // Apply trait bonuses
        offspringData.traits.forEach(trait => {
          if (trait.affects && offspring[trait.affects]) {
            offspring[trait.affects] += trait.bonus;
            // Cap at 100
            offspring[trait.affects] = Math.min(100, offspring[trait.affects]);
          }
        });
        
        // Add to player's horses
        player.addHorse(offspring);
        
        // Update breeding log with offspring ID
        const logEntry = this.breedingLog.find(entry => 
          entry.sireId === offspringData.sire.id && 
          entry.damId === offspringData.dam.id && 
          !entry.offspringId
        );
        
        if (logEntry) {
          logEntry.offspringId = offspring.id;
        }
        
        // Add to new offspring list
        newOffspring.push(offspring);
        
        // This foal is born, remove from pending
        return false;
      }
      // Keep in pending
      return true;
    });
    
    return newOffspring;
  }
  
  processCooldowns(horses, days) {
    // Reduce breeding cooldown for all horses
    horses.forEach(horse => {
      if (horse.breedingCooldown) {
        horse.breedingCooldown = Math.max(0, horse.breedingCooldown - days);
      }
    });
  }
  
  getBreedingStats(player) {
    // Calculate breeding stats for player
    const totalBreedings = this.breedingLog.filter(entry => 
      player.horses.some(h => h.id === entry.sireId) || 
      player.horses.some(h => h.id === entry.damId)
    ).length;
    
    const successfulBreedings = this.breedingLog.filter(entry => 
      entry.successful && (
        player.horses.some(h => h.id === entry.sireId) || 
        player.horses.some(h => h.id === entry.damId)
      )
    ).length;
    
    const successRate = totalBreedings > 0 ? (successfulBreedings / totalBreedings) * 100 : 0;
    
    return {
      totalBreedings,
      successfulBreedings,
      successRate,
      pendingBirths: this.pendingOffspring.filter(o => 
        player.horses.some(h => h.id === o.sire.id) || 
        player.horses.some(h => h.id === o.dam.id)
      ).length
    };
  }
  
  update(deltaTime, gameTime, player, horseManager) {
    // Process cooldowns for all horses
    if (deltaTime >= 1.0) { // If a day has passed
      this.processCooldowns(player.horses, Math.floor(deltaTime));
      
      // Check for new births
      const newOffspring = this.checkBirthdays(gameTime, player, horseManager);
      
      // Notify player of new offspring
      if (newOffspring.length > 0) {
        // In a real game, we'd trigger notifications here
        console.log(`${newOffspring.length} new foals have been born!`);
      }
    }
  }
}

// -------------------------------------------------
// MOBILE UI - Mobile Interface Implementation
// -------------------------------------------------
class MobileUI {
  constructor(game) {
    this.game = game;
    this.currentScreen = 'mainMenu';
    this.screens = {
      mainMenu: document.getElementById('main-menu-screen'),
      stable: document.getElementById('stable-screen'),
      horse: document.getElementById('horse-detail-screen'),
      race: document.getElementById('race-screen'),
      raceDetail: document.getElementById('race-detail-screen'),
      market: document.getElementById('market-screen'),
      breeding: document.getElementById('breeding-screen'),
      settings: document.getElementById('settings-screen')
    };
    
    // UI components
    this.components = {
      playerInfo: document.getElementById('player-info-bar'),
      bottomNav: document.getElementById('bottom-navigation'),
      messageContainer: document.getElementById('message-container')
    };
    
    // Initialize gesture handling
    this.initSwipeHandling();
  }
  
  initSwipeHandling() {
    let touchStartX = 0;
    let touchEndX = 0;
    
    document.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
    });
    
    document.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      this.handleSwipe(touchStartX, touchEndX);
    });
  }
  
  handleSwipe(startX, endX) {
    const swipeThreshold = 50;
    
    // Right to left swipe (next screen)
    if (startX - endX > swipeThreshold) {
      this.navigateToNextScreen();
    }
    
    // Left to right swipe (previous screen)
    if (endX - startX > swipeThreshold) {
      this.navigateToPreviousScreen();
    }
  }
  
  navigateToNextScreen() {
    const screenOrder = ['stable', 'race', 'market', 'breeding', 'settings'];
    const currentIndex = screenOrder.indexOf(this.currentScreen);
    
    if (currentIndex >= 0 && currentIndex < screenOrder.length - 1) {
      this.changeScreen(screenOrder[currentIndex + 1]);
    }
  }
  
  navigateToPreviousScreen() {
    const screenOrder = ['stable', 'race', 'market', 'breeding', 'settings'];
    const currentIndex = screenOrder.indexOf(this.currentScreen);
    
    if (currentIndex > 0) {
      this.changeScreen(screenOrder[currentIndex - 1]);
    }
  }
  
  changeScreen(screenName) {
    // Hide all screens
    Object.values(this.screens).forEach(screen => {
      if (screen) screen.style.display = 'none';
    });
    
    // Show selected screen
    if (this.screens[screenName]) {
      this.screens[screenName].style.display = 'block';
      this.currentScreen = screenName;
      
      // Update game's current screen
      this.game.currentScreen = screenName;
      
      // Update UI for the new screen
      this.updateScreenUI(screenName);
      
      // Update bottom navigation
      this.updateBottomNav(screenName);
    }
  }
  
  updateScreenUI(screenName) {
    switch(screenName) {
      case 'mainMenu':
        this.renderMainMenu();
        break;
      case 'stable':
        this.renderStableScreen();
        break;
      case 'horse':
        this.renderHorseDetailScreen();
        break;
      case 'race':
        this.renderRaceScreen();
        break;
      case 'raceDetail':
        this.renderRaceDetailScreen();
        break;
      case 'market':
        this.renderMarketScreen();
        break;
      case 'breeding':
        this.renderBreedingScreen();
        break;
      case 'settings':
        this.renderSettingsScreen();
        break;
    }
  }
  
  updateBottomNav(activeScreen) {
    const navButtons = this.components.bottomNav.querySelectorAll('button');
    
    navButtons.forEach(button => {
      const screenTarget = button.dataset.screen;
      
      if (screenTarget === activeScreen) {
        button.classList.add('active');
      } else {
        button.classList.remove('active');
      }
    });
  }
  
  // Render functions for each screen (simplified versions)
  renderMainMenu() {
    const menuScreen = this.screens.mainMenu;
    if (!menuScreen) return;
    
    menuScreen.innerHTML = `
      <div class="main-menu-container">
        <div class="game-logo">
          <h1>Equine Empire</h1>
          <h2>The Racing Tycoon</h2>
        </div>
        <div class="menu-buttons">
          <button id="new-game-btn" class="btn-primary">New Game</button>
          <button id="load-game-btn" class="btn-primary">Load Game</button>
          <button id="settings-btn" class="btn-secondary">Settings</button>
        </div>
      </div>
    `;
    
    // Add event listeners
    menuScreen.querySelector('#new-game-btn').addEventListener('click', () => {
      this.game.initialize();
      this.changeScreen('stable');
    });
    
    menuScreen.querySelector('#load-game-btn').addEventListener('click', () => {
      const loaded = this.game.load();
      if (loaded) {
        this.changeScreen('stable');
      } else {
        this.showMessage('No saved game found');
      }
    });
    
    menuScreen.querySelector('#settings-btn').addEventListener('click', () => {
      this.changeScreen('settings');
    });
  }
  
  renderStableScreen() {
    // Simplified - in a real game this would be more complex
    const stableScreen = this.screens.stable;
    if (!stableScreen) return;
    
    let stableHTML = `<h2>Your Stables</h2>`;
    
    // Display stables
    this.game.player.stables.forEach(stable => {
      stableHTML += `
        <div class="stable-card">
          <h3>${stable.name}</h3>
          <p>Capacity: ${stable.horses.length}/${stable.size}</p>
        </div>
      `;
    });
    
    // Display horses
    stableHTML += `<h2>Your Horses</h2>`;
    
    this.game.player.horses.forEach(horse => {
      stableHTML += `
        <div class="horse-card">
          <h3>${horse.name}</h3>
          <p>Rating: ${horse.calculateOverallRating()}</p>
        </div>
      `;
    });
    
    stableScreen.innerHTML = stableHTML;
  }
  
  renderRaceScreen() {
    // Simplified race screen rendering
  }
  
  renderHorseDetailScreen() {
    // Simplified horse detail screen rendering
  }
  
  renderRaceDetailScreen() {
    // Simplified race detail screen rendering
  }
  
  renderMarketScreen() {
    // Simplified market screen rendering
  }
  
  renderBreedingScreen() {
    // Simplified breeding screen rendering
  }
  
  renderSettingsScreen() {
    // Simplified settings screen rendering
  }
  
  showMessage(message) {
    const messageContainer = this.components.messageContainer;
    if (!messageContainer) return;
    
    const messageElement = document.createElement('div');
    messageElement.className = 'message';
    messageElement.textContent = message;
    
    messageContainer.appendChild(messageElement);
    
    // Auto-remove after a few seconds
    setTimeout(() => {
      messageElement.classList.add('fade-out');
      setTimeout(() => {
        messageElement.remove();
      }, 500);
    }, 3000);
  }
  
  updatePlayerInfo() {
    const playerInfo = this.components.playerInfo;
    if (!playerInfo) return;
    
    playerInfo.innerHTML = `
      <div class="player-info-content">
        <div class="player-name">${this.game.player.name}</div>
        <div class="player-funds">${this.game.player.funds.toLocaleString()}</div>
        <div class="player-reputation">Rep: ${this.game.player.reputation}</div>
        <div class="game-time">Day ${Math.floor(this.game.gameTime)}</div>
      </div>
    `;
  }
  
  initializeUI() {
    // Create DOM structure if not present
    this.createUIStructure();
    
    // Set up bottom navigation
    this.setupBottomNavigation();
    
    // Initialize main menu
    this.renderMainMenu();
    
    // Update player info
    this.updatePlayerInfo();
  }
  
  createUIStructure() {
    // If the DOM structure doesn't exist, create it
    if (!document.getElementById('game-container')) {
      const gameContainer = document.createElement('div');
      gameContainer.id = 'game-container';
      
      // Create player info bar
      const playerInfo = document.createElement('div');
      playerInfo.id = 'player-info-bar';
      this.components.playerInfo = playerInfo;
      
      // Create screen containers
      const screensContainer = document.createElement('div');
      screensContainer.id = 'screens-container';
      
      // Create individual screens
      const screenIds = [
        'main-menu-screen', 'stable-screen', 'horse-detail-screen', 
        'race-screen', 'race-detail-screen', 'market-screen', 
        'breeding-screen', 'settings-screen'
      ];
      
      screenIds.forEach(id => {
        const screen = document.createElement('div');
        screen.id = id;
        screen.className = 'game-screen';
        screen.style.display = 'none';
        screensContainer.appendChild(screen);
        this.screens[id.replace('-screen', '')] = screen;
      });
      
      // Show main menu by default
      this.screens.mainMenu.style.display = 'block';
      
      // Create bottom navigation
      const bottomNav = document.createElement('div');
      bottomNav.id = 'bottom-navigation';
      this.components.bottomNav = bottomNav;
      
      // Create message container
      const messageContainer = document.createElement('div');
      messageContainer.id = 'message-container';
      this.components.messageContainer = messageContainer;
      
      // Assemble structure
      gameContainer.appendChild(playerInfo);
      gameContainer.appendChild(screensContainer);
      gameContainer.appendChild(bottomNav);
      gameContainer.appendChild(messageContainer);
      
      document.body.appendChild(gameContainer);
    } else {
      // If structure exists, just get references
      this.components.playerInfo = document.getElementById('player-info-bar');
      this.components.bottomNav = document.getElementById('bottom-navigation');
      this.components.messageContainer = document.getElementById('message-container');
      
      // Get screen references
      Object.keys(this.screens).forEach(key => {
        this.screens[key] = document.getElementById(`${key}-screen`);
      });
    }
  }
  
  setupBottomNavigation() {
    const bottomNav = this.components.bottomNav;
    if (!bottomNav) return;
    
    bottomNav.innerHTML = `
      <button class="nav-button" data-screen="stable">
        <span class="nav-icon">üè†</span>
        <span class="nav-label">Stable</span>
      </button>
      <button class="nav-button" data-screen="race">
        <span class="nav-icon">üèÅ</span>
        <span class="nav-label">Race</span>
      </button>
      <button class="nav-button" data-screen="market">
        <span class="nav-icon">üí∞</span>
        <span class="nav-label">Market</span>
      </button>
      <button class="nav-button" data-screen="breeding">
        <span class="nav-icon">üêé</span>
        <span class="nav-label">Breeding</span>
      </button>
      <button class="nav-button" data-screen="settings">
        <span class="nav-icon">‚öôÔ∏è</span>
        <span class="nav-label">Settings</span>
      </button>
    `;
    
    // Add event listeners
    bottomNav.querySelectorAll('.nav-button').forEach(button => {
      button.addEventListener('click', (e) => {
        const screenName = e.currentTarget.dataset.screen;
        this.changeScreen(screenName);
      });
    });
  }
  
  update() {
    // Update player info
    this.updatePlayerInfo();
    
    // Update current screen
    this.updateScreenUI(this.currentScreen);
  }
}

// -------------------------------------------------
// GAME INITIALIZATION - Main Entry Point
// -------------------------------------------------

// Initialize the Game
function initializeGame() {
  console.log("Initializing Equine Empire: The Racing Tycoon...");
  
  // Create game instance
  const game = new GameManager();
  
  // Initialize game state
  game.initialize();
  
  // Set up event listeners (for UI interactions)
  setupEventListeners(game);
  
  // Start the game loop
  startGameLoop(game);
  
  return game;
}

// Set up UI event listeners (simplified)
function setupEventListeners(game) {
  // This would be implemented according to your UI framework
}

// Start the game loop
function startGameLoop(game) {
  let lastTime = Date.now();
  const gameSpeed = 1; // 1 in-game day per real second
  
  function gameLoop() {
    const currentTime = Date.now();
    const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
    
    // Calculate in-game time delta
    const gameTimeDelta = deltaTime * gameSpeed;
    
    // Update game state
    game.update(gameTimeDelta);
    
    lastTime = currentTime;
    
    // Schedule next frame
    requestAnimationFrame(gameLoop);
  }
  
  // Start the loop
  gameLoop();
}

// Helper function to format currency
function formatCurrency(amount) {
  return '      // Apply form and energy factors
      const formFactor = horse.form / 100;
      const energyFactor = horse.energy / 100;
      
      // Apply experience bonus (max 10%)
      const experienceBonus = Math.min(horse.experience / 1000, 0.1);
      
      // Calculate adjusted performance
      let adjustedPerformance = basePerformance * formFactor * energyFactor * 
                              (1 + experienceBonus) * (1 + jockeyBonus) * 
                              trackSuitability * distanceSuitability;
      
      // Apply track, distance, and weather modifiers
      adjustedPerformance *= trackConfig.speedFactor;
      adjustedPerformance *= distanceConfig.speedFactor;
      adjustedPerformance *= weatherConfig.speedFactor;
      
      // Add random variation (-10% to +10%)
      const variation = 0.9 + (Math.random() * 0.2);
      const finalPerformance = adjustedPerformance * variation;
      
      // Calculate race time based on distance and performance
      // Lower is better - this is a simplified calculation
      const raceTimeSeconds = (distanceConfig.distance / finalPerformance) * 10;
      
      results.push({
        horseId: horse.id,
        horseName: horse.name,
        jockeyName: participant.jockeyName,
        playerId: participant.playerId,
        performance: finalPerformance,
        time: raceTimeSeconds,
        position: 0 // Will be set after sorting
      });
    }
    
    // Sort by performance (best first)
    results.sort((a, b) => a.time - b.time);
    
    // Assign positions
    results.forEach((result, index) => {
      result.position = index + 1;
    });
    
    // Calculate prize money
    const prizes = this.calculatePrizes(race.purse, results.length);
    
    // Assign prize money and update horses
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      result.prize = prizes[i] || 0;
      
      // Find the horse and update it
      const horse = horses.find(h => h.id === result.horseId);
      if (horse) {
        // Record race result
        const raceRecord = {
          raceId: race.id,
          raceName: race.name,
          day: race.day,
          position: result.position,
          prize: result.prize,
          distance: race.distanceType,
          track: race.trackType,
          weather: race.weatherType
        };
        
        horse.recordRace(raceRecord);
        horse.inRace = false;
        
        // Award prize money to player if this is their horse
        if (result.playerId === player.name && result.prize > 0) {
          player.addFunds(result.prize);
          
          // Record win if position is 1
          if (result.position === 1) {
            player.recordRaceWon();
          }
        }
      }
    }
    
    // Mark race as completed
    race.completed = true;
    race.results = results;
    
    // Move race to history
    this.raceHistory.push(race);
    
    return results;
  }
  
  calculatePrizes(totalPurse, participants) {
    // Default prize distribution (percentages)
    const distribution = [0.6, 0.25, 0.1, 0.05]; // 1st, 2nd, 3rd, 4th
    
    // Create array with prizes for each position
    const prizes = [];
    
    // Calculate prize for each position
    for (let i = 0; i < participants; i++) {
      if (i < distribution.length) {
        prizes.push(Math.round(totalPurse * distribution[i]));
      } else {
        prizes.push(0); // No prize for positions beyond 4th
      }
    }
    
    return prizes;
  }
  
  scheduleRace(raceData) {
    const race = this.generateRace(raceData.type, raceData.day);
    this.races.push(race);
    
    // Add to calendar
    if (!this.raceCalendar[race.day]) {
      this.raceCalendar[race.day] = [];
    }
    this.raceCalendar[race.day].push(race);
    
    return race;
  }
  
  update(deltaTime) {
    // This could handle race scheduling, updating, etc.
  }
}

// -------------------------------------------------
// ECONOMY MANAGER - Game Economy & Progression
// -------------------------------------------------
class EconomyManager {
  constructor() {
    this.inflationRate = 0.002; // Daily inflation rate (0.2%)
    this.economyHealth = 1.0; // 0.5 to 1.5, affects prices and race purses
    this.marketTrends = {
      stableProperty: 1.0,
      horseBreeding: 1.0,
      racingPurses: 1.0,
      training: 1.0,
      jockeyFees: 1.0
    };
    this.upgradeCostMultipliers = {
      stable: 1.5, // Exponential cost increase for stable upgrades
      training: 1.4, // For training facility upgrades
      breeding: 1.6, // For breeding facility upgrades
      staff: 1.3 // For staff upgrades
    };
    
    // Achievement awards
    this.achievements = {
      firstWin: { name: "First Victory", reward: 5000, reputation: 5 },
      tenWins: { name: "Winning Streak", reward: 15000, reputation: 10 },
      championHorse: { name: "Champion Breeder", reward: 50000, reputation: 25 },
      stableEmpire: { name: "Stable Empire", reward: 100000, reputation: 50 }
    };
  }
  
  calculateUpgradeCost(basePrice, currentLevel, upgradeType) {
    const multiplier = this.upgradeCostMultipliers[upgradeType] || 1.5;
    return Math.round(basePrice * Math.pow(multiplier, currentLevel - 1));
  }
  
  adjustMarketTrends(gameTime) {
    // Adjust market trends every 30 in-game days
    if (Math.floor(gameTime) % 30 === 0) {
      // Generate random market fluctuations
      for (const trend in this.marketTrends) {
        // Random adjustment between -10% and +10%
        const adjustment = 0.9 + (Math.random() * 0.2);
        this.marketTrends[trend] *= adjustment;
        
        // Ensure trends stay within reasonable bounds
        this.marketTrends[trend] = Math.max(0.7, Math.min(1.3, this.marketTrends[trend]));
      }
      
      // Adjust overall economy health (slower changes)
      const economyAdjustment = 0.95 + (Math.random() * 0.1);
      this.economyHealth *= economyAdjustment;
      this.economyHealth = Math.max(0.8, Math.min(1.2, this.economyHealth));
    }
  }
  
  getMarketModifier(category) {
    // Get the current market modifier for a specific category
    const trend = this.marketTrends[category] || 1.0;
    return trend * this.economyHealth;
  }
  
  applyInflation(gameTime) {
    // Compound daily inflation
    const daysPassed = Math.floor(gameTime);
    return Math.pow(1 + this.inflationRate, daysPassed);
  }
  
  calculateHorseValue(horse, gameTime) {
    // Get base market value from horse
    let value = horse.calculateMarketValue();
    
    // Apply market trends for horse breeding
    value *= this.getMarketModifier('horseBreeding');
    
    // Apply inflation over time
    value *= this.applyInflation(gameTime);
    
    return Math.round(value);
  }
  
  calculateRacePurse(baseValue, raceType, gameTime) {
    // Base purse value
    let purse = baseValue;
    
    // Apply racing market trend
    purse *= this.getMarketModifier('racingPurses');
    
    // Apply inflation
    purse *= this.applyInflation(gameTime);
    
    return Math.round(purse);
  }
  
  calculateTrainingCost(basePrice, trainingType, gameTime) {
    // Base training cost
    let cost = basePrice;
    
    // Apply training market trend
    cost *= this.getMarketModifier('training');
    
    // Apply inflation
    cost *= this.applyInflation(gameTime);
    
    return Math.round(cost);
  }
  
  checkAchievements(player) {
    const achievements = [];
    
    // Check for first win
    if (player.stats.racesWon === 1) {
      achievements.push(this.awardAchievement('firstWin', player));
    }
    
    // Check for ten wins
    if (player.stats.racesWon === 10) {
      achievements.push(this.awardAchievement('tenWins', player));
    }
    
    // Check for champion horse (horse with 10+ wins)
    const championHorse = player.horses.find(horse => horse.wins >= 10);
    if (championHorse && !player.hasAchievement('championHorse')) {
      achievements.push(this.awardAchievement('championHorse', player));
    }
    
    // Check for stable empire (3+ stables)
    if (player.stables.length >= 3 && !player.hasAchievement('stableEmpire')) {
      achievements.push(this.awardAchievement('stableEmpire', player));
    }
    
    return achievements;
  }
  
  awardAchievement(achievementId, player) {
    const achievement = this.achievements[achievementId];
    if (!achievement) return null;
    
    // Award money
    if (achievement.reward) {
      player.addFunds(achievement.reward);
    }
    
    // Award reputation
    if (achievement.reputation) {
      player.addReputation(achievement.reputation);
    }
    
    // Record achievement
    player.addAchievement(achievementId);
    
    return {
      id: achievementId,
      name: achievement.name,
      reward: achievement.reward,
      reputation: achievement.reputation
    };
  }
  
  getSponsorshipOffers(player) {
    // Generate sponsorship offers based on player reputation
    const offers = [];
    
    // Only offer sponsorships to players with some reputation
    if (player.reputation < 10) return offers;
    
    // Number and value of offers scales with reputation
    const offerCount = Math.min(3, Math.floor(player.reputation / 20) + 1);
    
    for (let i = 0; i < offerCount; i++) {
      const value = 5000 + (player.reputation * 500) + (Math.random() * 10000);
      
      offers.push({
        id: 'sponsor_' + Date.now() + '_' + i,
        name: this.generateSponsorName(),
        value: Math.round(value),
        duration: 10, // lasts for 10 in-game days
        requirements: {
          racesEntered: Math.floor(Math.random() * 3) + 1,
          minimumPosition: Math.floor(Math.random() * 3) + 1
        }
      });
    }
    
    return offers;
  }
  
  generateSponsorName() {
    const prefixes = ["Royal", "Golden", "Elite", "Premium", "Champion", "Victory"];
    const types = ["Racing", "Equestrian", "Thoroughbred", "Stallion", "Racing Cup"];
    const suffixes = ["Feeds", "Equipment", "Gear", "Supplements", "Apparel", "Stakes"];
    
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const type = types[Math.floor(Math.random() * types.length)];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    
    return `${prefix} ${type} ${suffix}`;
  }
}

// -------------------------------------------------
// MARKET MANAGER - Horse Trading & Marketplace
// -------------------------------------------------
class MarketManager {
  constructor() {
    this.marketHorses = []; // Horses available for purchase
    this.playerListings = []; // Horses listed by players
    this.marketRefreshDays = 7; // Market refreshes every 7 days
    this.lastRefreshDay = 0;
    this.marketFees = {
      listingFee: 500, // Fee to list a horse
      salesTax: 0.05 // 5% tax on sales
    };
    this.horseManager = new HorseManager(); // For generating horses
    this.economyManager = new EconomyManager(); // For pricing
  }
  
  refreshMarket(gameTime = 0, playerLevel = 1) {
    // Clear previous market horses
    this.marketHorses = [];
    
    // Number of horses scales with player level
    const horseCount = 5 + Math.floor(playerLevel / 2);
    
    // Generate new market horses with varying quality
    for (let i = 0; i < horseCount; i++) {
      // Calculate quality level - mostly average with some better options
      let qualityLevel = 1;
      
      const roll = Math.random();
      if (roll > 0.9) {
        qualityLevel = Math.min(5, playerLevel + 1); // Excellent quality
      } else if (roll > 0.7) {
        qualityLevel = Math.min(4, playerLevel); // Good quality
      } else if (roll > 0.4) {
        qualityLevel = Math.min(3, Math.max(1, playerLevel - 1)); // Average quality
      } else {
        qualityLevel = Math.max(1, playerLevel - 2); // Lower quality
      }
      
      // Generate a single horse of appropriate quality
      const horse = this.horseManager.generateMarketHorses(1, qualityLevel)[0];
      
      // Apply market pricing
      horse.marketValue = this.economyManager.calculateHorseValue(horse, gameTime);
      horse.purchasePrice = horse.marketValue;
      
      this.marketHorses.push(horse);
    }
    
    this.lastRefreshDay = Math.floor(gameTime);
    return this.marketHorses;
  }
  
  getAvailableHorses() {
    // Combine market horses and player listings
    return [...this.marketHorses, ...this.playerListings];
  }
  
  buyHorse(horse, player) {
    // Check if player has enough funds
    if (player.funds < horse.purchasePrice) {
      return { success: false, message: "Insufficient funds" };
    }
    
    // Check if the horse is still available
    const marketIndex = this.marketHorses.findIndex(h => h.id === horse.id);
    const listingIndex = this.playerListings.findIndex(h => h.id === horse.id);
    
    if (marketIndex === -1 && listingIndex === -1) {
      return { success: false, message: "Horse is no longer available" };
    }
    
    // Process the purchase
    player.removeFunds(horse.purchasePrice);
    
    // If buying from player listing, pay the seller
    if (listingIndex !== -1) {
      const listing = this.playerListings[listingIndex];
      const sellerPayment = Math.round(horse.purchasePrice * (1 - this.marketFees.salesTax));
      
      // In a real game, we'd add funds to the seller player
      // But here we'll just remove from listings
      this.playerListings.splice(listingIndex, 1);
    } else {
      // Remove from market horses
      this.marketHorses.splice(marketIndex, 1);
    }
    
    // Add horse to player's collection
    horse.forSale = false;
    horse.purchasePrice = horse.marketValue;
    player.addHorse(horse);
    
    return { success: true, message: "Purchase successful", horse: horse };
  }
  
  sellHorse(horse, price, player) {
    // Check if player owns the horse
    const playerHorse = player.horses.find(h => h.id === horse.id);
    if (!playerHorse) {
      return { success: false, message: "You don't own this horse" };
    }
    
    // Check if horse is eligible for sale
    if (playerHorse.inRace || playerHorse.inTraining) {
      return { success: false, message: "Horse is racing or in training" };
    }
    
    // Check if player can afford listing fee
    if (player.funds < this.marketFees.listingFee) {
      return { success: false, message: "Insufficient funds for listing fee" };
    }
    
    // Charge listing fee
    player.removeFunds(this.marketFees.listingFee);
    
    // Remove horse from player
    player.removeHorse(horse.id);
    
    // Set sale price and mark for sale
    horse.forSale = true;
    horse.purchasePrice = price;
    
    // Add to player listings
    this.playerListings.push({
      ...horse,
      sellerId: player.id,
      sellerName: player.name,
      listingDate: Date.now()
    });
    
    // Record the sale in player stats
    player.recordHorseSold();
    
    return { success: true, message: "Horse listed for sale", listingFee: this.marketFees.listingFee };
  }
  
  cancelListing(horseId, player) {
    // Find the listing
    const listingIndex = this.playerListings.findIndex(h => h.id === horseId && h.sellerId === player.id);
    
    if (listingIndex === -1) {
      return { success: false, message: "Listing not found" };
    }
    
    // Get the horse from listings
    const horse = this.playerListings[listingIndex];
    
    // Remove from listings
    this.playerListings.splice(listingIndex, 1);
    
    // Return horse to player
    horse.forSale = false;
    player.addHorse(horse);
    
    return { success: true, message: "Listing canceled" };
  }
  
  getMarketTrends(gameTime) {
    // Return current market trends (prices, demand, etc.)
    return {
      averagePrice: this.calculateAverageMarketPrice(),
      highestValue: this.getHighestValueHorse(),
      listingCount: this.playerListings.length,
      marketSize: this.marketHorses.length,
      nextRefresh: this.lastRefreshDay + this.marketRefreshDays - Math.floor(gameTime)
    };
  }
  
  calculateAverageMarketPrice() {
    const allHorses = [...this.marketHorses, ...this.playerListings];
    if (allHorses.length === 0) return 0;
    
    const totalValue = allHorses.reduce((sum, horse) => sum + horse.purchasePrice, 0);
    return Math.round(totalValue / allHorses.length);
  }
  
  getHighestValueHorse() {
    const allHorses = [...this.marketHorses, ...this.playerListings];
    if (allHorses.length === 0) return null;
    
    return allHorses.reduce((highest, horse) => 
      (horse.purchasePrice > highest.purchasePrice) ? horse : highest
    );
  }
  
  specialMarketEvent(eventData) {
    switch (eventData.type) {
      case 'sale':
        // Apply discount to all market horses
        this.marketHorses.forEach(horse => {
          horse.purchasePrice = Math.round(horse.marketValue * 0.8); // 20% off
        });
        break;
      case 'premium':
        // Add special premium horses to the market
        const premiumHorses = this.horseManager.generateMarketHorses(eventData.count || 3, eventData.quality || 5);
        premiumHorses.forEach(horse => {
          horse.marketValue = horse.calculateMarketValue() * 1.2; // Premium pricing
          horse.purchasePrice = horse.marketValue;
        });
        this.marketHorses.push(...premiumHorses);
        break;
      case 'auction':
        // In a real implementation, this would set up a special auction
        // with bidding mechanics
        break;
    }
  }
  
  update(gameTime) {
    // Check if it's time to refresh the market
    const currentDay = Math.floor(gameTime);
    if (currentDay >= this.lastRefreshDay + this.marketRefreshDays) {
      this.refreshMarket(gameTime);
    }
  }
}

// -------------------------------------------------
// EVENT MANAGER - Game Events & Challenges
// -------------------------------------------------
class EventManager {
  constructor() {
    this.events = []; // Scheduled events
    this.activeEvents = []; // Currently active events
    this.eventTypes = {
      race: { name: "Special Race", duration: 3 }, // Special race event
      sale: { name: "Market Sale", duration: 5 }, // Discount on market horses
      challenge: { name: "Racing Challenge", duration: 7 }, // Special racing challenge
      breeding: { name: "Breeding Season", duration: 10 }, // Increased breeding success
      tournament: { name: "Tournament", duration: 14 } // Series of connected races
    };
    
    // Challenge templates
    this.challengeTemplates = [
      {
        id: "rookie_challenge",
        name: "Rookie Challenge",
        description: "Win 3 local races with a horse under training level 5",
        requirement: { type: "wins", count: 3, raceType: "local", maxTrainingLevel: 5 },
        reward: { money: 10000, reputation: 5 }
      },
      {
        id: "distance_specialist",
        name: "Distance Specialist",
        description: "Win 2 long-distance races with the same horse",
        requirement: { type: "wins", count: 2, distanceType: "long", sameHorse: true },
        reward: { money: 15000, reputation: 10 }
      },
      {
        id: "breeding_master",
        name: "Breeding Master",
        description: "Breed a horse with combined attributes over E rating",
        requirement: { type: "breeding", minimumRating: 85 },
        reward: { money: 25000, reputation: 15 }
      },
      {
        id: "stable_expansion",
        name: "Stable Expansion",
        description: "Own 10 horses across all your stables",
        requirement: { type: "ownership", horses: 10 },
        reward: { money: 20000, reputation: 12 }
      },
      {
        id: "champion_trainer",
        name: "Champion Trainer",
        description: "Train a horse to level 10",
        requirement: { type: "training", level: 10 },
        reward: { money: 30000, reputation: 20 }
      }
    ];
  }
  
  scheduleEvent(eventType, startDay, data = {}) {
    const eventConfig = this.eventTypes[eventType];
    if (!eventConfig) return null;
    
    const event = {
      id: 'event_' + Date.now() + '_' + Math.floor(Math.random() * 1000),
      type: eventType,
      name: data.name || eventConfig.name,
      startDay: startDay,
      duration: data.duration || eventConfig.duration,
      endDay: startDay + (data.duration || eventConfig.duration),
      data: data
    };
    
    this.events.push(event);
    return event;
  }
  
  getEventsForDay(day) {
    return this.events.filter(event => event.startDay <= day && event.endDay >= day);
  }
  
  hasActiveEvent() {
    return this.activeEvents.length > 0;
  }
  
  getActiveEvent() {
    return this.activeEvents.length > 0 ? this.activeEvents[0] : null;
  }
  
  generateChallenge(playerLevel) {
    // Select a challenge appropriate for player level
    const eligibleChallenges = this.challengeTemplates.filter(challenge => 
      !challenge.minLevel || playerLevel >= challenge.minLevel
    );
    
    if (eligibleChallenges.length === 0) return null;
    
    // Randomly select a challenge
    const challenge = eligibleChallenges[Math.floor(Math.random() * eligibleChallenges.length)];
    
    // Clone the challenge and assign a unique ID
    return {
      ...challenge,
      id: challenge.id + '_' + Date.now(),
      startTime: Date.now(),
      completed: false
    };
  }
  
  checkChallengeCompletion(challenge, player, event) {
    if (!challenge || challenge.completed) return false;
    
    switch (challenge.requirement.type) {
      case "wins":
        return this.checkWinsChallenge(challenge, player, event);
      case "breeding":
        return this.checkBreedingChallenge(challenge, player, event);
      case "ownership":
        return this.checkOwnershipChallenge(challenge, player);
      case "training":
        return this.checkTrainingChallenge(challenge, player, event);
      default:
        return false;
    }
  }
  
  checkWinsChallenge(challenge, player, event) {
    // Check if the event is a race win
    if (event.type !== 'raceWin') return false;
    
    // Check race type if specified
    if (challenge.requirement.raceType && event.raceType !== challenge.requirement.raceType) {
      return false;
    }
    
    // Check distance type if specified
    if (challenge.requirement.distanceType && event.distanceType !== challenge.requirement.distanceType) {
      return false;
    }
    
    // Check training level if specified
    if (challenge.requirement.maxTrainingLevel) {
      const horse = player.horses.find(h => h.id === event.horseId);
      if (!horse || horse.trainingLevel > challenge.requirement.maxTrainingLevel) {
        return false;
      }
    }
    
    // Check same horse requirement
    if (challenge.requirement.sameHorse) {
      // Store the horse ID for first win
      if (!challenge.horseId) {
        challenge.horseId = event.horseId;
      } else if (challenge.horseId !== event.horseId) {
        return false; // Different horse
      }
    }
    
    // Increment win counter
    challenge.currentWins = (challenge.currentWins || 0) + 1;
    
    // Check if requirement is met
    return challenge.currentWins >= challenge.requirement.count;
  }
  
  checkBreedingChallenge(challenge, player, event) {
    // Check if the event is a breeding event
    if (event.type !== 'breeding') return false;
    
    // Check the offspring's rating
    const offspring = player.horses.find(h => h.id === event.offspringId);
    if (!offspring) return false;
    
    const rating = offspring.calculateOverallRating();
    return rating >= challenge.requirement.minimumRating;
  }
  
  checkOwnershipChallenge(challenge, player) {
    // Simply check if player owns enough horses
    return player.horses.length >= challenge.requirement.horses;
  }
  
  checkTrainingChallenge(challenge, player, event) {
    // Check if any horse reaches the required training level
    if (event.type !== 'horseLevelUp') return false;
    
    const horse = player.horses.find(h => h.id === event.horseId);
    if (!horse) return false;
    
    return horse.trainingLevel >= challenge.requirement.level;
  }
  
  update(deltaTime, gameTime) {
    const currentDay = Math.floor(gameTime);
    
    // Check for events that should start
    const newActiveEvents = this.events.filter(event => 
      event.startDay === currentDay && !this.activeEvents.includes(event)
    );
    
    // Add new active events
    this.activeEvents.push(...newActiveEvents);
    
    // Remove expired events
    this.activeEvents = this.activeEvents.filter(event => event.endDay >= currentDay);
    
    // Periodically schedule new events
    if (currentDay % 15 === 0) { // Every 15 days
      // Schedule a random event 5-10 days in the future
      const eventTypes = Object.keys(this.eventTypes);
      const randomType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
      const startDay = currentDay + 5 + Math.floor(Math.random() * 6);
      
      this.scheduleEvent(randomType, startDay);
    }
  }
}

// -------------------------------------------------
// BREEDING SYSTEM - Horse Breeding & Genetics
// -------------------------------------------------
class BreedingSystem {
  constructor() {
    this.breedingLog = []; // History of breeding pairs and results
    this.breedingCooldown = 60; // Days before a horse can breed again
    this.gestationPeriod = 30; // Days before foal is born
    this.breedingFees = {
      basic: 5000,
      premium: 15000,
      elite: 50000
    };
    this.pendingOffspring = []; // Offspring waiting to be born
    this.seasonalBonus = 0; // Bonus during breeding season events
    
    // Genetic traits that can be passed down
    this.geneticTraits = [
      { name: "Sprinter", affects: "speed", bonus: 5 },
      { name: "Marathoner", affects: "stamina", bonus: 5 },
      { name: "Agile Mover", affects: "agility", bonus: 5 },
      { name: "Quick Starter", affects: "acceleration", bonus: 5 },
      { name: "Iron Will", affects: "consistency", bonus: 5 },
      { name: "Calm Spirit", affects: "temperament", bonus: 5 }
    ];
  }
  
  canBreed(horse) {
    // Check if horse meets breeding requirements
    return (
      horse.canBreed && // Age and health allow breeding
      !horse.inRace && // Not currently racing
      !horse.injured && // Not injured
      !horse.breedingCooldown // Not on cooldown
    );
  }
  
  breedHorses(sire, dam, player, horseManager) {
    // Check if both horses can breed
    if (!this.canBreed(sire) || !this.canBreed(dam)) {
      return { success: false, message: "One or both horses cannot breed at this time" };
    }
    
    // Check if player has enough funds for basic breeding fee
    if (player.funds < this.breedingFees.basic) {
      return {  age(days) {
    // Convert days to years (simplified - assuming 365 days per year)
    const yearsToAdd = days / 365;
    this.age += yearsToAdd;
    
    // Update breeding eligibility
    this.canBreed = this.age >= 3;
    
    // Check for retirement (based on age and random factor)
    if (this.age > 10 && Math.random() < (this.age - 10) * 0.1) {
      this.retire();
    }
    
    return this.age;
  }
  
  retire() {
    this.retired = true;
    this.inTraining = false;
    this.inRace = false;
    
    // Can still breed but can't race
    return true;
  }
  
  recordRace(raceResult) {
    this.races.push(raceResult);
    
    // Update stats
    if (raceResult.position === 1) {
      this.wins++;
    } else if (raceResult.position <= 3) {
      this.placings++;
    }
    
    // Gain experience
    this.experience += 10;
    
    // Update form based on performance
    if (raceResult.position <= 3) {
      this.form = Math.min(100, this.form + 5);
    } else {
      this.form = Math.max(50, this.form - 3);
    }
    
    // Energy depletion based on race distance
    let energyLoss = 30; // Default for medium races
    if (raceResult.distance === 'short') energyLoss = 20;
    if (raceResult.distance === 'long') energyLoss = 40;
    
    this.energy = Math.max(10, this.energy - energyLoss);
    
    // Update market value after race
    this.marketValue = this.calculateMarketValue();
    this.breedingValue = this.calculateBreedingValue();
    
    return raceResult;
  }
  
  addOffspring(offspringId) {
    this.offspring.push(offspringId);
  }
  
  serialize() {
    return {
      id: this.id,
      name: this.name,
      age: this.age,
      speed: this.speed,
      stamina: this.stamina,
      agility: this.agility,
      acceleration: this.acceleration,
      consistency: this.consistency,
      temperament: this.temperament,
      form: this.form,
      energy: this.energy,
      experience: this.experience,
      preferredDistance: this.preferredDistance,
      preferredSurface: this.preferredSurface,
      preferredWeather: this.preferredWeather,
      trainingLevel: this.trainingLevel,
      trainingProgress: this.trainingProgress,
      pedigree: this.pedigree,
      breedingValue: this.breedingValue,
      offspring: this.offspring,
      breedingCooldown: this.breedingCooldown,
      traits: this.traits,
      races: this.races,
      wins: this.wins,
      placings: this.placings,
      purchasePrice: this.purchasePrice,
      marketValue: this.marketValue,
      forSale: this.forSale,
      inTraining: this.inTraining,
      inRace: this.inRace,
      injured: this.injured,
      injuryTime: this.injuryTime,
      canBreed: this.canBreed,
      retired: this.retired
    };
  }
  
  deserialize(data) {
    this.id = data.id;
    this.name = data.name;
    this.age = data.age;
    this.speed = data.speed;
    this.stamina = data.stamina;
    this.agility = data.agility;
    this.acceleration = data.acceleration;
    this.consistency = data.consistency;
    this.temperament = data.temperament;
    this.form = data.form;
    this.energy = data.energy;
    this.experience = data.experience;
    this.preferredDistance = data.preferredDistance;
    this.preferredSurface = data.preferredSurface;
    this.preferredWeather = data.preferredWeather;
    this.trainingLevel = data.trainingLevel;
    this.trainingProgress = data.trainingProgress;
    this.pedigree = data.pedigree;
    this.breedingValue = data.breedingValue;
    this.offspring = data.offspring;
    this.breedingCooldown = data.breedingCooldown || 0;
    this.traits = data.traits || [];
    this.races = data.races;
    this.wins = data.wins;
    this.placings = data.placings;
    this.purchasePrice = data.purchasePrice;
    this.marketValue = data.marketValue;
    this.forSale = data.forSale;
    this.inTraining = data.inTraining;
    this.inRace = data.inRace;
    this.injured = data.injured;
    this.injuryTime = data.injuryTime;
    this.canBreed = data.canBreed;
    this.retired = data.retired;
  }
}

// -------------------------------------------------
// HORSE MANAGER - Horse Creation & Management
// -------------------------------------------------
class HorseManager {
  constructor() {
    this.horseNames = [
      // Male names
      "Thunder Bolt", "Midnight Express", "Royal Flush", "Storm Runner", "Blazing Speed",
      "Noble Steed", "Gallant Prince", "Diamond King", "Maverick", "Triumph",
      // Female names
      "Mystic Beauty", "Graceful Lady", "Starlight Dancer", "Silk Ribbon", "Sweet Victory",
      "Queen's Jewel", "Elegant Spirit", "Summer Breeze", "Golden Symphony", "Majestic Rose"
    ];
  }
  
  generateHorseName(gender = null) {
    const nameIndex = Math.floor(Math.random() * this.horseNames.length);
    return this.horseNames[nameIndex];
  }
  
  generateStarterHorses(count) {
    const horses = [];
    
    for (let i = 0; i < count; i++) {
      // Generate slightly different starter horses
      const attributes = {
        age: 2,
        speed: 45 + Math.floor(Math.random() * 10),
        stamina: 45 + Math.floor(Math.random() * 10),
        agility: 45 + Math.floor(Math.random() * 10),
        acceleration: 45 + Math.floor(Math.random() * 10),
        consistency: 50 + Math.floor(Math.random() * 10),
        temperament: 50 + Math.floor(Math.random() * 10),
        preferredDistance: ['short', 'medium', 'long'][Math.floor(Math.random() * 3)],
        preferredSurface: ['dirt', 'turf', 'synthetic'][Math.floor(Math.random() * 3)],
        trainingLevel: 1,
        purchasePrice: 5000
      };
      
      const name = this.generateHorseName();
      const horse = new Horse(null, name, attributes);
      
      horses.push(horse);
    }
    
    return horses;
  }
  
  generateMarketHorses(count, qualityLevel) {
    const horses = [];
    
    // Quality affects attribute ranges
    const baseMin = 40 + (qualityLevel * 5);
    const baseMax = 55 + (qualityLevel * 5);
    
    for (let i = 0; i < count; i++) {
      const attributes = {
        age: 2 + Math.floor(Math.random() * 4), // 2-5 years old
        speed: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        stamina: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        agility: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        acceleration: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        consistency: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        temperament: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        preferredDistance: ['short', 'medium', 'long'][Math.floor(Math.random() * 3)],
        preferredSurface: ['dirt', 'turf', 'synthetic'][Math.floor(Math.random() * 3)],
        trainingLevel: 1 + Math.floor(Math.random() * qualityLevel)
      };
      
      const name = this.generateHorseName();
      const horse = new Horse(null, name, attributes);
      
      // Set purchase price and make available for sale
      horse.marketValue = horse.calculateMarketValue();
      horse.purchasePrice = horse.marketValue;
      horse.forSale = true;
      
      horses.push(horse);
    }
    
    return horses;
  }
  
  breedHorses(sire, dam) {
    // Check if both parents can breed
    if (!sire.canBreed || !dam.canBreed) {
      return null;
    }
    
    // Generate offspring attributes based on parents
    const attributes = {
      age: 0, // Newborn
      speed: this.inheritAttribute(sire.speed, dam.speed),
      stamina: this.inheritAttribute(sire.stamina, dam.stamina),
      agility: this.inheritAttribute(sire.agility, dam.agility),
      acceleration: this.inheritAttribute(sire.acceleration, dam.acceleration),
      consistency: this.inheritAttribute(sire.consistency, dam.consistency),
      temperament: this.inheritAttribute(sire.temperament, dam.temperament),
      preferredDistance: Math.random() < 0.5 ? sire.preferredDistance : dam.preferredDistance,
      preferredSurface: Math.random() < 0.5 ? sire.preferredSurface : dam.preferredSurface,
      trainingLevel: 1,
      traits: [] // Will be populated by genetic traits
    };
    
    // Generate pedigree
    const generation = Math.max(sire.pedigree.generation, dam.pedigree.generation) + 1;
    const pedigree = {
      sire: sire.id,
      dam: dam.id,
      generation: generation,
      lineage: [
        ...new Set([
          ...(sire.pedigree.lineage || []),
          ...(dam.pedigree.lineage || []),
          sire.id,
          dam.id
        ])
      ]
    };
    
    // Generate name
    const name = this.generateHorseName();
    
    // Create the offspring
    const offspring = new Horse(null, name, attributes, pedigree);
    
    // Record offspring in parents
    sire.addOffspring(offspring.id);
    dam.addOffspring(offspring.id);
    
    return offspring;
  }
  
  inheritAttribute(sireValue, damValue) {
    // Calculate base inheritance (average of parents with random variation)
    const baseValue = (sireValue + damValue) / 2;
    
    // Add random variation (-5 to +5)
    const variation = (Math.random() * 10) - 5;
    
    // Ensure within limits
    return Math.min(100, Math.max(1, Math.round(baseValue + variation)));
  }
  
  ageHorse(horse, days) {
    return horse.age(days);
  }
  
  update(deltaTime) {
    // This could handle global horse-related updates
    // For example, automatic aging based on game time
  }
}

// -------------------------------------------------
// STABLE - Stable Entity
// -------------------------------------------------
class Stable {
  constructor(id, name, size, level = 1) {
    this.id = id || this.generateId();
    this.name = name || "Unnamed Stable";
    this.size = size || 3; // Max number of horses
    this.level = level; // Affects training effectiveness
    this.horses = []; // Horse IDs
    this.staff = []; // Staff IDs
    this.facilities = {
      training: 1, // Training facility level
      breeding: 0, // Breeding facility level (0 = none)
      recovery: 1, // Recovery facility level
      comfort: 1 // Comfort level (affects horse wellbeing)
    };
    this.upgradeCosts = {
      size: 10000, // Base cost to add a stall
      training: 15000, // Base cost to upgrade training
      breeding: 25000, // Base cost to add/upgrade breeding
      recovery: 12000, // Base cost to upgrade recovery
      comfort: 8000 // Base cost to upgrade comfort
    };
    this.dailyUpkeep = 500 + (size * 100); // Daily maintenance cost
  }
  
  generateId() {
    return 'stable_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
  }
  
  addHorse(horse) {
    if (this.horses.length >= this.size) {
      return false; // Stable is full
    }
    
    if (typeof horse === 'object') {
      this.horses.push(horse.id);
    } else {
      this.horses.push(horse); // Assuming it's an ID
    }
    
    return true;
  }
  
  removeHorse(horseId) {
    const index = this.horses.indexOf(horseId);
    if (index >= 0) {
      this.horses.splice(index, 1);
      return true;
    }
    return false;
  }
  
  upgradeSize(player) {
    const cost = this.getUpgradeCost('size');
    
    if (player.funds < cost) {
      return false; // Not enough funds
    }
    
    player.removeFunds(cost);
    this.size += 1;
    
    // Increase upkeep
    this.dailyUpkeep += 100;
    
    // Update cost for next upgrade
    this.upgradeCosts.size = Math.floor(this.upgradeCosts.size * 1.5);
    
    return true;
  }
  
  upgradeFacility(facilityType, player) {
    if (!this.facilities.hasOwnProperty(facilityType)) {
      return false; // Invalid facility
    }
    
    const cost = this.getUpgradeCost(facilityType);
    
    if (player.funds < cost) {
      return false; // Not enough funds
    }
    
    player.removeFunds(cost);
    this.facilities[facilityType] += 1;
    
    // Increase upkeep
    this.dailyUpkeep += 50;
    
    // Update cost for next upgrade
    this.upgradeCosts[facilityType] = Math.floor(this.upgradeCosts[facilityType] * 1.5);
    
    return true;
  }
  
  getUpgradeCost(upgradeType) {
    const baseCost = this.upgradeCosts[upgradeType];
    const currentLevel = upgradeType === 'size' ? this.size : this.facilities[upgradeType];
    
    // Exponential cost increase based on current level
    return Math.floor(baseCost * Math.pow(1.2, currentLevel - 1));
  }
  
  getTrainingBonus() {
    // Calculate training effectiveness bonus based on facility level
    return 1 + (this.facilities.training * 0.1); // +10% per level
  }
  
  getRecoveryBonus() {
    // Calculate recovery rate bonus based on facility level
    return 1 + (this.facilities.recovery * 0.15); // +15% per level
  }
  
  getBreedingBonus() {
    // Calculate breeding success bonus based on facility level
    return this.facilities.breeding * 0.05; // +5% per level
  }
  
  getComfortBonus() {
    // Calculate comfort bonus (affects horse wellbeing)
    return this.facilities.comfort * 0.1; // +10% per level
  }
  
  processDaily(horses, player) {
    // Charge daily upkeep
    player.removeFunds(this.dailyUpkeep);
    
    // Process each horse
    for (const horseId of this.horses) {
      const horse = horses.find(h => h.id === horseId);
      if (horse) {
        // Apply recovery bonus for injured horses
        if (horse.injured) {
          const recoveryDays = 1 * this.getRecoveryBonus();
          horse.recover(recoveryDays);
        }
        
        // Apply comfort bonus for resting horses
        if (!horse.inTraining && !horse.inRace) {
          const restAmount = 1 * this.getComfortBonus();
          horse.rest(restAmount);
        }
      }
    }
  }
  
  serialize() {
    return {
      id: this.id,
      name: this.name,
      size: this.size,
      level: this.level,
      horses: [...this.horses],
      staff: [...this.staff],
      facilities: { ...this.facilities },
      upgradeCosts: { ...this.upgradeCosts },
      dailyUpkeep: this.dailyUpkeep
    };
  }
  
  deserialize(data, horsesArray) {
    this.id = data.id;
    this.name = data.name;
    this.size = data.size;
    this.level = data.level;
    this.horses = [...data.horses];
    this.staff = [...data.staff];
    this.facilities = { ...data.facilities };
    this.upgradeCosts = { ...data.upgradeCosts };
    this.dailyUpkeep = data.dailyUpkeep;
  }
}

// -------------------------------------------------
// STABLE MANAGER - Stable Creation & Management
// -------------------------------------------------
class StableManager {
  constructor() {
    this.stableTypes = [
      { name: "Small Farm", size: 3, level: 1, cost: 10000 },
      { name: "Country Stable", size: 5, level: 2, cost: 25000 },
      { name: "Racing Stable", size: 8, level: 3, cost: 50000 },
      { name: "Elite Facility", size: 12, level: 4, cost: 100000 },
      { name: "Championship Complex", size: 20, level: 5, cost: 250000 }
    ];
  }
  
  createStable(name, level) {
    const type = this.stableTypes[level - 1] || this.stableTypes[0];
    const stable = new Stable(null, name, type.size, level);
    return stable;
  }
  
  expandStable(stable, player) {
    return stable.upgradeSize(player);
  }
  
  upgradeFacility(stable, facilityType, player) {
    return stable.upgradeFacility(facilityType, player);
  }
  
  purchaseNewStable(player, stableType) {
    const type = this.stableTypes[stableType - 1];
    if (!type || player.funds < type.cost) {
      return false;
    }
    
    player.removeFunds(type.cost);
    const newStable = this.createStable(`${player.name}'s ${type.name}`, type.level);
    player.addStable(newStable);
    
    return newStable;
  }
  
  renameStable(stable, newName) {
    stable.name = newName;
    return true;
  }
  
  update(deltaTime, player) {
    // Process daily operations for all stables
    const dayPassed = deltaTime >= 1.0;
    
    if (dayPassed) {
      for (const stable of player.stables) {
        stable.processDaily(player.horses, player);
      }
    }
  }
}

// -------------------------------------------------
// RACE MANAGER - Race Creation & Simulation
// -------------------------------------------------
class RaceManager {
  constructor() {
    this.races = []; // Upcoming races
    this.raceHistory = []; // Past races
    this.raceCalendar = {}; // Calendar of scheduled races by date
    this.raceTypes = {
      local: {
        name: "Local Race",
        entryFee: 500,
        purse: 5000,
        prestige: 1,
        difficulty: 1
      },
      regional: {
        name: "Regional Cup",
        entryFee: 1500,
        purse: 15000,
        prestige: 2,
        difficulty: 2
      },
      national: {
        name: "National Championship",
        entryFee: 5000,
        purse: 50000,
        prestige: 3,
        difficulty: 3
      },
      elite: {
        name: "Elite Cup",
        entryFee: 10000,
        purse: 100000,
        prestige: 4,
        difficulty: 4
      },
      international: {
        name: "International Classic",
        entryFee: 25000,
        purse: 250000,
        prestige: 5,
        difficulty: 5
      }
    };
    
    this.trackTypes = {
      dirt: { name: "Dirt Track", speedFactor: 1.0 },
      turf: { name: "Turf Track", speedFactor: 0.95 },
      synthetic: { name: "Synthetic Track", speedFactor: 1.05 }
    };
    
    this.distances = {
      short: { name: "Sprint", distance: 1200, speedFactor: 1.1, staminaFactor: 0.9 },
      medium: { name: "Mile", distance: 1600, speedFactor: 1.0, staminaFactor: 1.0 },
      long: { name: "Endurance", distance: 2400, speedFactor: 0.9, staminaFactor: 1.1 }
    };
    
    this.weatherTypes = {
      sunny: { name: "Sunny", speedFactor: 1.0 },
      cloudy: { name: "Cloudy", speedFactor: 0.98 },
      rainy: { name: "Rainy", speedFactor: 0.9 },
      muddy: { name: "Muddy", speedFactor: 0.85 },
      hot: { name: "Hot", speedFactor: 0.95 },
      cold: { name: "Cold", speedFactor: 0.97 }
    };
  }
  
  initializeRaceCalendar() {
    // Create a 30-day race calendar with different types of races
    for (let day = 1; day <= 30; day++) {
      let races = [];
      
      // Always have local races available
      races.push(this.generateRace('local', day));
      
      // Regional races every 3 days
      if (day % 3 === 0) {
        races.push(this.generateRace('regional', day));
      }
      
      // National races every 7 days
      if (day % 7 === 0) {
        races.push(this.generateRace('national', day));
      }
      
      // Elite races every 14 days
      if (day % 14 === 0) {
        races.push(this.generateRace('elite', day));
      }
      
      // International race once a month
      if (day === 28) {
        races.push(this.generateRace('international', day));
      }
      
      this.raceCalendar[day] = races;
    }
    
    return this.raceCalendar;
  }
  
  generateRace(raceType, day) {
    // Get race type configuration
    const typeConfig = this.raceTypes[raceType];
    
    // Select random track type
    const trackTypes = Object.keys(this.trackTypes);
    const trackType = trackTypes[Math.floor(Math.random() * trackTypes.length)];
    
    // Select random distance
    const distanceTypes = Object.keys(this.distances);
    const distanceType = distanceTypes[Math.floor(Math.random() * distanceTypes.length)];
    
    // Select random weather
    const weatherTypes = Object.keys(this.weatherTypes);
    const weatherType = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
    
    // Generate a unique race ID
    const raceId = 'race_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Create race object
    const race = {
      id: raceId,
      name: this.generateRaceName(raceType, trackType, distanceType),
      type: raceType,
      day: day,
      trackType: trackType,
      distanceType: distanceType,
      weatherType: weatherType,
      entryFee: typeConfig.entryFee,
      purse: typeConfig.purse,
      prestige: typeConfig.prestige,
      difficulty: typeConfig.difficulty,
      participants: [], // Will be populated when horses enter
      results: null, // Will be populated after race is run
      completed: false
    };
    
    return race;
  }
  
  generateRaceName(raceType, trackType, distanceType) {
    const prefixes = [
      "Golden", "Silver", "Royal", "Champion's", "Victory", 
      "Prestigious", "Grand", "Majestic", "Classic", "Elite"
    ];
    
    const suffixes = [
      "Cup", "Stakes", "Derby", "Invitational", "Challenge", 
      "Trophy", "Championship", "Crown", "Prix", "Handicap"
    ];
    
    const trackPrefix = this.trackTypes[trackType].name.split(' ')[0];
    const distancePrefix = this.distances[distanceType].name;
    const racePrefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const raceSuffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    
    return `${racePrefix} ${trackPrefix} ${distancePrefix} ${raceSuffix}`;
  }
  
  getAvailableRaces(day) {
    // Get races for a specific day
    return this.raceCalendar[day % 30 || 30] || [];
  }
  
  enterRace(race, horse, jockey, player) {
    // Check if horse is eligible
    if (horse.injured || horse.inRace || horse.retired) {
      return { success: false, message: "Horse is not eligible to race" };
    }
    
    // Check if player has enough funds for entry fee
    if (player.funds < race.entryFee) {
      return { success: false, message: "Insufficient funds for entry fee" };
    }
    
    // Charge entry fee
    player.removeFunds(race.entryFee);
    
    // Mark horse as in race
    horse.inRace = true;
    
    // Add horse to race participants
    race.participants.push({
      horseId: horse.id,
      horseName: horse.name,
      jockeyId: jockey ? jockey.id : null,
      jockeyName: jockey ? jockey.name : "House Jockey",
      playerId: player.name,
      odds: this.calculateOdds(horse, race)
    });
    
    // Record that player entered a race
    player.recordRaceEntered();
    
    return { success: true, message: "Successfully entered race" };
  }
  
  calculateOdds(horse, race) {
    // Calculate base odds based on horse's overall rating
    const overallRating = horse.calculateOverallRating();
    
    // Track preference adjustment
    let trackPreference = 1.0;
    if (horse.preferredSurface === race.trackType) {
      trackPreference = 1.1; // 10% boost if preferred track
    }
    
    // Distance preference adjustment
    let distancePreference = 1.0;
    if (horse.preferredDistance === race.distanceType) {
      distancePreference = 1.1; // 10% boost if preferred distance
    }
    
    // Calculate effective rating with preferences
    const effectiveRating = overallRating * trackPreference * distancePreference;
    
    // Calculate odds (lower rating = higher odds)
    // Base odds will range from about 2-1 (best horses) to 50-1 (worst horses)
    const baseOdds = Math.max(2, Math.round((100 - effectiveRating) / 2));
    
    // Adjust for race difficulty
    const difficultyAdjustment = 0.8 + (race.difficulty * 0.2);
    const finalOdds = Math.round(baseOdds * difficultyAdjustment);
    
    return finalOdds;
  }
  
  simulateRace(race, horses, player) {
    if (race.completed) {
      return race.results;
    }
    
    // Get all horses in the race
    const raceHorses = race.participants.map(participant => {
      const horse = horses.find(h => h.id === participant.horseId);
      return {
        participant: participant,
        horse: horse
      };
    });
    
    // Get track configuration
    const trackConfig = this.trackTypes[race.trackType];
    const distanceConfig = this.distances[race.distanceType];
    const weatherConfig = this.weatherTypes[race.weatherType];
    
    // Prepare results array
    const results = [];
    
    // Simulate each horse's performance
    for (const { participant, horse } of raceHorses) {
      // Calculate jockey skill bonus (0-10%)
      const jockeyBonus = participant.jockeyId ? 0.1 : 0; // Simplified - would come from jockey object
      
      // Calculate track suitability
      const trackSuitability = horse.preferredSurface === race.trackType ? 1.1 : 1.0;
      
      // Calculate distance suitability
      const distanceSuitability = horse.preferredDistance === race.distanceType ? 1.1 : 1.0;
      
      // Calculate base performance from horse attributes
      let basePerformance = 0;
      
      // Sprint race emphasizes speed and acceleration
      if (race.distanceType === 'short') {
        basePerformance = (horse.speed * 0.4) + (horse.acceleration * 0.3) + 
                          (horse.stamina * 0.1) + (horse.agility * 0.2);
      }
      // Medium race is balanced
      else if (race.distanceType === 'medium') {
        basePerformance = (horse.speed * 0.3) + (horse.acceleration * 0.2) + 
                          (horse.stamina * 0.3) + (horse.agility * 0.2);
      }
      // Long race emphasizes stamina
      else {
        basePerformance = (horse.speed * 0.2) + (horse.acceleration * 0.1) + 
                          (horse.stamina * 0.5) + (horse.agility * 0.2);
      }
      
      // Apply form and energy.listings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-m);
}

.listing-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  gap: var(--spacing-s);
}

/* Breeding Screen */
.breeding-screen-container {
  padding-bottom: var(--spacing-xl);
}

.breeding-stats-panel {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-s);
}

.stat-item {
  display: flex;
  flex-direction: column;
  padding: var(--spacing-s);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.breeding-form {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.selection-container {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-m);
}

@media (min-width: 480px) {
  .selection-container {
    grid-template-columns: 1fr 1fr;
  }
}

.breeding-details {
  background-color: #f5f5f5;
  padding: var(--spacing-s);
  border-radius: var(--border-radius-s);
  margin-bottom: var(--spacing-m);
}

.no-breeding-horses {
  background-color: #f5f5f5;
  padding: var(--spacing-s);
  border-radius: var(--border-radius-s);
  text-align: center;
}

.pending-births {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.births-list {
  display: grid;
  gap: var(--spacing-s);
}

.birth-item {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-s);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.breeding-advice {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.breeding-advice ul {
  padding-left: var(--spacing-l);
}

.breeding-advice li {
  margin-bottom: var(--spacing-xs);
}

/* Settings Screen */
.settings-screen-container {
  padding-bottom: var(--spacing-xl);
}

.settings-section {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.setting-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-s) 0;
  border-bottom: 1px solid var(--border-color);
}

.setting-item:last-child {
  border-bottom: none;
}

.setting-control {
  min-width: 100px;
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 24px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .toggle-slider {
  background-color: var(--primary-color);
}

input:checked + .toggle-slider:before {
  transform: translateX(26px);
}

.save-load-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-s);
}

.save-load-buttons button {
  flex: 1;
}

.about-info {
  text-align: center;
}

#back-to-game-btn {
  display: block;
  margin: 0 auto;
  width: 100%;
  max-width: 300px;
  padding: var(--spacing-m);
}

/* Responsive Adjustments */
@media (max-width: 480px) {
  .facility-levels {
    grid-template-columns: 1fr;
  }
  
  .upgrade-facilities-container {
    grid-template-columns: 1fr;
  }
  
  .horse-stats {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .race-details {
    flex-direction: column;
  }
  
  .race-actions {
    flex-direction: column;
  }
  
  .winner-card {
    width: 100%;
  }
  
  .stats-grid {
    grid-template-columns: 1fr;
  }
}

/* Animations */
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.pulse {
  animation: pulse 2s infinite;
}

/* Loading Indicator */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 5px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: white;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Utils */
.text-center {
  text-align: center;
}

.mb-0 {
  margin-bottom: 0;
}

.hidden {
  display: none;
}

.truncate {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Will be populated by MobileUI -->
    </div>

    <script>
// -------------------------------------------------
// GAME MANAGER - Central Control System
// -------------------------------------------------
class GameManager {
  constructor() {
    this.player = new Player();
    this.horseManager = new HorseManager();
    this.stableManager = new StableManager();
    this.raceManager = new RaceManager();
    this.economyManager = new EconomyManager();
    this.eventManager = new EventManager();
    this.marketManager = new MarketManager();
    this.breedingSystem = new BreedingSystem();
    this.initialized = false;
    
    // Game state
    this.currentScreen = 'mainMenu'; // mainMenu, stable, race, market, breeding, etc.
    this.gameTime = 0; // In-game time tracker (days)
  }
  
  initialize() {
    // Set up initial game state
    this.player.initialize("Player", 10000); // Starting with $10,000
    
    // Create initial stable with one starter horse
    const starterStable = this.stableManager.createStable("Your First Stable", 1);
    this.player.addStable(starterStable);
    
    // Generate starter horse options
    const starterHorses = this.horseManager.generateStarterHorses(3);
    
    // Add first horse to player's stable
    this.player.addHorse(starterHorses[0]);
    
    // Initialize race calendar
    this.raceManager.initializeRaceCalendar();
    
    // Initialize market with some horses
    this.marketManager.refreshMarket();
    
    this.initialized = true;
    console.log("Game initialized successfully!");
  }
  
  update(deltaTime) {
    // Main game loop - update all systems
    if (!this.initialized) return;
    
    // Update in-game time
    this.gameTime += deltaTime;
    
    // Update managers
    this.raceManager.update(deltaTime);
    this.stableManager.update(deltaTime, this.player);
    this.horseManager.update(deltaTime);
    this.eventManager.update(deltaTime, this.gameTime);
    this.breedingSystem.update(deltaTime, this.gameTime, this.player, this.horseManager);
    this.marketManager.update(this.gameTime);
    this.economyManager.adjustMarketTrends(this.gameTime);
    
    // Check for scheduled events
    if (this.eventManager.hasActiveEvent()) {
      const activeEvent = this.eventManager.getActiveEvent();
      this.handleEvent(activeEvent);
    }
    
    // Refresh market periodically
    if (Math.floor(this.gameTime) % 7 === 0 && Math.floor(this.gameTime) !== Math.floor(this.gameTime - deltaTime)) {
      this.marketManager.refreshMarket(this.gameTime, Math.max(1, Math.floor(this.player.reputation / 10)));
    }
    
    // Check for achievements
    this.economyManager.checkAchievements(this.player);
  }
  
  handleEvent(event) {
    // Process active events
    switch(event.type) {
      case 'race':
        this.raceManager.scheduleRace(event.data);
        break;
      case 'market':
        this.marketManager.specialMarketEvent(event.data);
        break;
      case 'challenge':
        this.player.addChallenge(event.data);
        break;
      case 'breeding':
        // Apply breeding season bonuses
        this.breedingSystem.seasonalBonus = 0.2; // 20% bonus to breeding success
        break;
      default:
        console.log(`Unknown event type: ${event.type}`);
    }
  }
  
  changeScreen(screen) {
    this.currentScreen = screen;
    // Trigger UI update
    console.log(`Screen changed to: ${screen}`);
  }
  
  save() {
    // Save game state to local storage
    const gameState = {
      player: this.player.serialize(),
      gameTime: this.gameTime,
      breedingSystem: {
        pendingOffspring: this.breedingSystem.pendingOffspring.map(offspring => ({
          sireId: offspring.sire.id,
          damId: offspring.dam.id,
          birthDay: offspring.birthDay,
          traits: offspring.traits
        })),
        breedingLog: this.breedingSystem.breedingLog
      },
      marketManager: {
        marketHorses: this.marketManager.marketHorses.map(horse => horse.serialize()),
        playerListings: this.marketManager.playerListings.map(horse => horse.serialize()),
        lastRefreshDay: this.marketManager.lastRefreshDay
      },
      raceManager: {
        races: this.raceManager.races,
        raceHistory: this.raceManager.raceHistory
      },
      eventManager: {
        events: this.eventManager.events,
        activeEvents: this.eventManager.activeEvents
      }
    };
    
    localStorage.setItem('equineEmpireSave', JSON.stringify(gameState));
    console.log("Game saved successfully!");
    return true;
  }
  
  load() {
    // Load game state from local storage
    const savedState = localStorage.getItem('equineEmpireSave');
    if (!savedState) {
      console.log("No saved game found.");
      return false;
    }
    
    try {
      const gameState = JSON.parse(savedState);
      
      // Load player data
      this.player.deserialize(gameState.player);
      
      // Load game time
      this.gameTime = gameState.gameTime;
      
      // Load breeding system data
      if (gameState.breedingSystem) {
        // We need to convert the serialized offspring data back to full objects
        this.breedingSystem.pendingOffspring = gameState.breedingSystem.pendingOffspring.map(offspringData => {
          const sire = this.player.horses.find(h => h.id === offspringData.sireId);
          const dam = this.player.horses.find(h => h.id === offspringData.damId);
          
          if (sire && dam) {
            return {
              sire: sire,
              dam: dam,
              birthDay: offspringData.birthDay,
              traits: offspringData.traits
            };
          }
          return null;
        }).filter(offspring => offspring !== null);
        
        this.breedingSystem.breedingLog = gameState.breedingSystem.breedingLog;
      }
      
      // Load market data
      if (gameState.marketManager) {
        // Convert serialized horses back to Horse objects
        this.marketManager.marketHorses = gameState.marketManager.marketHorses.map(horseData => {
          const horse = new Horse();
          horse.deserialize(horseData);
          return horse;
        });
        
        this.marketManager.playerListings = gameState.marketManager.playerListings.map(horseData => {
          const horse = new Horse();
          horse.deserialize(horseData);
          return horse;
        });
        
        this.marketManager.lastRefreshDay = gameState.marketManager.lastRefreshDay;
      }
      
      // Load race data
      if (gameState.raceManager) {
        this.raceManager.races = gameState.raceManager.races;
        this.raceManager.raceHistory = gameState.raceManager.raceHistory;
      }
      
      // Load event data
      if (gameState.eventManager) {
        this.eventManager.events = gameState.eventManager.events;
        this.eventManager.activeEvents = gameState.eventManager.activeEvents;
      }
      
      this.initialized = true;
      console.log("Game loaded successfully!");
      return true;
    } catch (error) {
      console.error("Error loading saved game:", error);
      return false;
    }
  }
}

// -------------------------------------------------
// PLAYER - Player Data & Progression
// -------------------------------------------------
class Player {
  constructor() {
    this.name = "";
    this.funds = 0;
    this.stables = [];
    this.horses = [];
    this.reputation = 0;
    this.trophies = [];
    this.challenges = [];
    this.achievements = [];
    this.stats = {
      racesEntered: 0,
      racesWon: 0,
      horsesBred: 0,
      horsesSold: 0,
      totalEarnings: 0
    };
  }
  
  initialize(name, startingFunds) {
    this.name = name;
    this.funds = startingFunds;
    this.reputation = 1; // Starting reputation level
  }
  
  addFunds(amount) {
    this.funds += amount;
    this.stats.totalEarnings += amount;
    return this.funds;
  }
  
  removeFunds(amount) {
    if (this.funds >= amount) {
      this.funds -= amount;
      return true;
    }
    return false;
  }
  
  addStable(stable) {
    this.stables.push(stable);
  }
  
  addHorse(horse) {
    this.horses.push(horse);
    // Assign to first stable if available
    if (this.stables.length > 0) {
      this.stables[0].addHorse(horse);
    }
  }
  
  removeHorse(horseId) {
    const horseIndex = this.horses.findIndex(h => h.id === horseId);
    if (horseIndex >= 0) {
      // Also remove from stable
      for (const stable of this.stables) {
        stable.removeHorse(horseId);
      }
      
      const removedHorse = this.horses.splice(horseIndex, 1)[0];
      return removedHorse;
    }
    return null;
  }
  
  addReputation(amount) {
    this.reputation += amount;
    return this.reputation;
  }
  
  addTrophy(trophy) {
    this.trophies.push(trophy);
  }
  
  addChallenge(challenge) {
    this.challenges.push(challenge);
  }
  
  completeChallenge(challengeId) {
    const challengeIndex = this.challenges.findIndex(c => c.id === challengeId);
    if (challengeIndex >= 0) {
      const challenge = this.challenges[challengeIndex];
      this.challenges.splice(challengeIndex, 1);
      
      // Apply rewards
      this.addFunds(challenge.rewardMoney || 0);
      this.addReputation(challenge.rewardReputation || 0);
      
      return challenge;
    }
    return null;
  }
  
  addAchievement(achievementId) {
    if (!this.achievements.includes(achievementId)) {
      this.achievements.push(achievementId);
      return true;
    }
    return false;
  }
  
  hasAchievement(achievementId) {
    return this.achievements.includes(achievementId);
  }
  
  recordRaceEntered() {
    this.stats.racesEntered++;
  }
  
  recordRaceWon() {
    this.stats.racesWon++;
  }
  
  recordHorseBred() {
    this.stats.horsesBred++;
  }
  
  recordHorseSold() {
    this.stats.horsesSold++;
  }
  
  getHorseCount() {
    return this.horses.length;
  }
  
  getStableCount() {
    return this.stables.length;
  }
  
  serialize() {
    return {
      name: this.name,
      funds: this.funds,
      stables: this.stables.map(stable => stable.serialize()),
      horses: this.horses.map(horse => horse.serialize()),
      reputation: this.reputation,
      trophies: this.trophies,
      challenges: this.challenges,
      achievements: this.achievements,
      stats: { ...this.stats }
    };
  }
  
  deserialize(data) {
    this.name = data.name;
    this.funds = data.funds;
    this.reputation = data.reputation;
    this.trophies = data.trophies;
    this.challenges = data.challenges;
    this.achievements = data.achievements || [];
    this.stats = { ...data.stats };
    
    // Deserialize horses
    this.horses = data.horses.map(horseData => {
      const horse = new Horse();
      horse.deserialize(horseData);
      return horse;
    });
    
    // Deserialize stables
    this.stables = data.stables.map(stableData => {
      const stable = new Stable();
      stable.deserialize(stableData, this.horses);
      return stable;
    });
  }
}

// -------------------------------------------------
// HORSE - Core Horse Entity
// -------------------------------------------------
class Horse {
  constructor(id, name, attributes = {}, pedigree = null) {
    this.id = id || this.generateId();
    this.name = name || "Unnamed Horse";
    this.age = attributes.age || 2; // Starting age in years
    
    // Core attributes
    this.speed = attributes.speed || 50; // 0-100
    this.stamina = attributes.stamina || 50; // 0-100
    this.agility = attributes.agility || 50; // 0-100
    this.acceleration = attributes.acceleration || 50; // 0-100
    this.consistency = attributes.consistency || 50; // 0-100
    this.temperament = attributes.temperament || 50; // 0-100 (higher = calmer)
    
    // Performance attributes
    this.form = 100; // 0-100, current physical condition
    this.energy = 100; // 0-100, current energy level
    this.experience = 0; // Racing experience, increases with races
    this.preferredDistance = attributes.preferredDistance || 'medium'; // short, medium, long
    this.preferredSurface = attributes.preferredSurface || 'dirt'; // dirt, turf, synthetic
    this.preferredWeather = attributes.preferredWeather || 'sunny'; // sunny, rainy, etc.
    
    // Training and progress
    this.trainingLevel = attributes.trainingLevel || 1;
    this.trainingProgress = 0; // 0-100, progress to next level
    
    // Genetics and breeding
    this.pedigree = pedigree || {
      sire: null, // Father
      dam: null, // Mother
      generation: 1, // Generation number
      lineage: [] // Array of notable ancestors
    };
    this.breedingValue = this.calculateBreedingValue();
    this.offspring = []; // IDs of offspring
    this.breedingCooldown = 0; // Days before can breed again
    this.traits = attributes.traits || [];
    
    // Racing history
    this.races = [];
    this.wins = 0;
    this.placings = 0; // 2nd or 3rd place finishes
    
    // Market info
    this.purchasePrice = attributes.purchasePrice || 5000;
    this.marketValue = this.calculateMarketValue();
    this.forSale = false;
    
    // Status flags
    this.inTraining = false;
    this.inRace = false;
    this.injured = false;
    this.injuryTime = 0; // Days until recovered
    this.canBreed = this.age >= 3; // Can breed at age 3+
    this.retired = false;
  }
  
  generateId() {
    return 'horse_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
  }
  
  calculateOverallRating() {
    // Calculate overall performance rating based on attributes
    const baseRating = (
      this.speed * 0.25 +
      this.stamina * 0.25 +
      this.agility * 0.15 +
      this.acceleration * 0.15 +
      this.consistency * 0.1 +
      this.temperament * 0.1
    );
    
    // Apply form factor
    const formFactor = this.form / 100;
    
    // Apply experience bonus (max 10%)
    const experienceBonus = Math.min(this.experience / 100, 0.1);
    
    return Math.round(baseRating * formFactor * (1 + experienceBonus));
  }
  
  calculateMarketValue() {
    // Base value from attributes
    const attributeValue = (
      this.speed * 300 +
      this.stamina * 250 +
      this.agility * 200 +
      this.acceleration * 200 +
      this.consistency * 150 +
      this.temperament * 100
    );
    
    // Age modifier - value peaks at 4-5 years
    let ageModifier = 1.0;
    if (this.age < 3) ageModifier = 0.8; // Young, unproven
    else if (this.age >= 3 && this.age <= 5) ageModifier = 1.2; // Prime
    else if (this.age > 5 && this.age <= 8) ageModifier = 0.9; // Mature
    else if (this.age > 8) ageModifier = 0.7; // Senior
    
    // Racing record bonus
    const recordBonus = this.wins * 5000 + this.placings * 2000;
    
    // Pedigree bonus
    let pedigreeBonus = 0;
    if (this.pedigree.generation > 1) {
      pedigreeBonus = 10000 * (this.pedigree.generation - 1);
    }
    
    // Calculate final value
    let value = (attributeValue * ageModifier) + recordBonus + pedigreeBonus;
    
    // Minimum value floor
    value = Math.max(value, 2000);
    
    return Math.round(value);
  }
  
  calculateBreedingValue() {
    // Base value from best attributes
    const bestAttributes = Math.max(this.speed, this.stamina, this.agility, this.acceleration);
    
    // Racing success factor
    const racingFactor = 1 + (this.wins * 0.1);
    
    // Pedigree factor
    let pedigreeFactor = 1.0;
    if (this.pedigree.generation > 1) {
      pedigreeFactor = 1.0 + ((this.pedigree.generation - 1) * 0.2);
    }
    
    return Math.round(bestAttributes * racingFactor * pedigreeFactor);
  }
  
  train(trainingType, intensity) {
    // Skip if injured or in race
    if (this.injured || this.inRace) return false;
    
    this.inTraining = true;
    
    // Training effectiveness based on intensity (1-5)
    const effectivenessMultiplier = 0.5 + (intensity * 0.1);
    
    // Energy cost based on intensity
    const energyCost = 5 + (intensity * 3);
    this.energy = Math.max(0, this.energy - energyCost);
    
    // Progress gain based on training type
    let progressGain = 10 * effectivenessMultiplier;
    
    // Different training types improve different attributes
    switch (trainingType) {
      case 'speed':
        this.speed += 0.2 * effectivenessMultiplier;
        break;
      case 'stamina':
        this.stamina += 0.2 * effectivenessMultiplier;
        break;
      case 'agility':
        this.agility += 0.2 * effectivenessMultiplier;
        break;
      case 'acceleration':
        this.acceleration += 0.2 * effectivenessMultiplier;
        break;
      default:
        // General training improves all attributes slightly
        this.speed += 0.05 * effectivenessMultiplier;
        this.stamina += 0.05 * effectivenessMultiplier;
        this.agility += 0.05 * effectivenessMultiplier;
        this.acceleration += 0.05 * effectivenessMultiplier;
    }
    
    // Cap attributes at 100
    this.speed = Math.min(100, this.speed);
    this.stamina = Math.min(100, this.stamina);
    this.agility = Math.min(100, this.agility);
    this.acceleration = Math.min(100, this.acceleration);
    
    // Injury risk based on intensity and current energy
    const injuryRisk = (intensity * 0.5) * (1 - (this.energy / 100));
    if (Math.random() < injuryRisk) {
      this.injury(Math.floor(Math.random() * 10) + 1); // 1-10 days
      return false;
    }
    
    // Update training progress
    this.trainingProgress += progressGain;
    if (this.trainingProgress >= 100) {
      this.levelUp();
    }
    
    // Update market value after training
    this.marketValue = this.calculateMarketValue();
    
    this.inTraining = false;
    return true;
  }
  
  levelUp() {
    this.trainingLevel++;
    this.trainingProgress = 0;
    
    // Bonus improvement on level up
    this.speed += 1;
    this.stamina += 1;
    this.agility += 1;
    this.acceleration += 1;
    
    // Cap attributes at 100
    this.speed = Math.min(100, this.speed);
    this.stamina = Math.min(100, this.stamina);
    this.agility = Math.min(100, this.agility);
    this.acceleration = Math.min(100, this.acceleration);
    
    return this.trainingLevel;
  }
  
  rest(days) {
    // Energy recovery
    this.energy = Math.min(100, this.energy + (days * 15));
    
    // Form improvement if resting
    this.form = Math.min(100, this.form + (days * 5));
    
    return this.energy;
  }
  
  injury(days) {
    this.injured = true;
    this.injuryTime = days;
    this.inTraining = false;
    this.inRace = false;
    
    // Reduce form due to injury
    this.form = Math.max(50, this.form - 20);
    
    return days;
  }
  
  recover(days) {
    if (!this.injured) return 0;
    
    this.injuryTime -= days;
    if (this.injuryTime <= 0) {
      this.injured = false;
      this.injuryTime = 0;
      return 0;
    }
    
    return this.injuryTime;
  }
  
  age(days) {
    // Convert days to years (simplified - assuming 365 days per year)
    const yearsToAdd = days / 365;
    this.age += yearsToAdd;
    
    // Update breeding eligibility
    this.canBreed = this.age >= 3;
    
    // Check for retirement (based on age and random factor)
    if (this.age > 10 && Math.<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Equine Empire: The Racing Tycoon</title>
    <style>
/* ---------------------------------------------------
   EQUINE EMPIRE: THE RACING TYCOON - Mobile CSS
   --------------------------------------------------- */

/* Base Styles */
:root {
  /* Color Palette */
  --primary-color: #2c7a5a;
  --primary-dark: #1c5b3f;
  --primary-light: #3d9b72;
  --secondary-color: #8a572f;
  --secondary-dark: #664022;
  --secondary-light: #aa7349;
  --accent-color: #d3a157;
  --accent-dark: #b88a3f;
  --accent-light: #e2ba76;
  
  /* UI Colors */
  --background-color: #f8f5f1;
  --card-background: #ffffff;
  --text-color: #333333;
  --text-light: #666666;
  --text-inverse: #ffffff;
  --border-color: #e0e0e0;
  --success-color: #4caf50;
  --warning-color: #ff9800;
  --danger-color: #f44336;
  --info-color: #2196f3;
  
  /* Race Types Colors */
  --local-race: #8bc34a;
  --regional-race: #03a9f4;
  --national-race: #9c27b0;
  --elite-race: #ff9800;
  --international-race: #d32f2f;
  
  /* Typography */
  --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  --heading-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  
  /* Spacing */
  --spacing-xs: 4px;
  --spacing-s: 8px;
  --spacing-m: 16px;
  --spacing-l: 24px;
  --spacing-xl: 32px;
  
  /* Borders */
  --border-radius-s: 4px;
  --border-radius-m: 8px;
  --border-radius-l: 12px;
  --border-radius-xl: 20px;
  
  /* Shadows */
  --shadow-small: 0 2px 4px rgba(0,0,0,0.1);
  --shadow-medium: 0 4px 8px rgba(0,0,0,0.1);
  --shadow-large: 0 8px 16px rgba(0,0,0,0.1);
  
  /* Animations */
  --transition-speed: 0.3s;
}

/* Dark Mode Colors */
.dark-mode {
  --background-color: #222;
  --card-background: #333;
  --text-color: #f0f0f0;
  --text-light: #aaa;
  --border-color: #444;
}

/* Base Elements */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  font-family: var(--font-family);
  font-size: 16px;
  line-height: 1.5;
  color: var(--text-color);
  background-color: var(--background-color);
  height: 100%;
  width: 100%;
  overflow-x: hidden;
}

h1, h2, h3, h4, h5, h6 {
  font-family: var(--heading-font);
  margin-bottom: var(--spacing-m);
  font-weight: 600;
}

h1 {
  font-size: 2.5rem;
}

h2 {
  font-size: 2rem;
}

h3 {
  font-size: 1.5rem;
}

h4 {
  font-size: 1.25rem;
}

p {
  margin-bottom: var(--spacing-m);
}

button {
  font-family: var(--font-family);
  cursor: pointer;
  border: none;
  outline: none;
  padding: var(--spacing-s) var(--spacing-m);
  border-radius: var(--border-radius-m);
  font-weight: 500;
  transition: background-color var(--transition-speed), transform var(--transition-speed);
}

button:active {
  transform: scale(0.98);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background-color: var(--primary-color);
  color: white;
}

.btn-primary:hover {
  background-color: var(--primary-dark);
}

.btn-secondary {
  background-color: var(--secondary-color);
  color: white;
}

.btn-secondary:hover {
  background-color: var(--secondary-dark);
}

.btn-danger {
  background-color: var(--danger-color);
  color: white;
}

.btn-danger:hover {
  background-color: #d32f2f;
}

/* Game Container */
#game-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  max-width: 600px;
  margin: 0 auto;
  position: relative;
}

/* Player Info Bar */
#player-info-bar {
  background-color: var(--primary-color);
  color: white;
  padding: var(--spacing-s) var(--spacing-m);
  position: sticky;
  top: 0;
  z-index: 100;
}

.player-info-content {
  display: flex;
  justify-content: space-between;
}

.player-funds {
  font-weight: bold;
}

/* Screens Container */
#screens-container {
  flex: 1;
  overflow-y: auto;
  padding-bottom: 60px; /* Space for bottom nav */
}

.game-screen {
  padding: var(--spacing-m);
}

/* Bottom Navigation */
#bottom-navigation {
  background-color: var(--card-background);
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: space-around;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 60px;
  max-width: 600px;
  margin: 0 auto;
  z-index: 100;
}

.nav-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: none;
  color: var(--text-light);
  flex: 1;
  padding: var(--spacing-xs);
}

.nav-button.active {
  color: var(--primary-color);
}

.nav-icon {
  font-size: 1.5rem;
  margin-bottom: var(--spacing-xs);
}

.nav-label {
  font-size: 0.75rem;
}

/* Message Container */
#message-container {
  position: fixed;
  top: 70px;
  left: 0;
  right: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  z-index: 1000;
}

.message {
  background-color: var(--primary-color);
  color: white;
  padding: var(--spacing-s) var(--spacing-m);
  border-radius: var(--border-radius-m);
  margin-bottom: var(--spacing-s);
  box-shadow: var(--shadow-medium);
  max-width: 80%;
  text-align: center;
  animation: slide-in 0.3s ease-out;
}

.message.fade-out {
  animation: fade-out 0.5s ease-out forwards;
}

@keyframes slide-in {
  from { transform: translateY(-20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: var(--shadow-large);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-m);
  border-bottom: 1px solid var(--border-color);
}

.modal-header h3 {
  margin: 0;
}

.close-modal {
  background: none;
  font-size: 1.5rem;
  color: var(--text-light);
  padding: 0;
}

.modal-body {
  padding: var(--spacing-m);
}

.modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-m);
  padding: var(--spacing-m);
  border-top: 1px solid var(--border-color);
}

/* Main Menu Screen */
.main-menu-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xl) var(--spacing-m);
  min-height: 80vh;
}

.game-logo {
  text-align: center;
  margin-bottom: var(--spacing-xl);
}

.game-logo h1 {
  color: var(--primary-color);
  font-size: 2.5rem;
  margin-bottom: var(--spacing-xs);
}

.game-logo h2 {
  color: var(--secondary-color);
  font-size: 1.5rem;
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-m);
  width: 80%;
}

.menu-buttons button {
  padding: var(--spacing-m);
  font-size: 1.2rem;
}

/* Stable Screen */
.stable-screen-container {
  padding-bottom: var(--spacing-xl);
}

.stables-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.stable-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.stable-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-m);
}

.stable-level {
  background-color: var(--primary-light);
  color: white;
  padding: var(--spacing-xs) var(--spacing-s);
  border-radius: var(--border-radius-s);
  font-size: 0.9rem;
}

.stable-info {
  margin-bottom: var(--spacing-m);
}

.facility-levels {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-s);
  margin-bottom: var(--spacing-m);
}

.facility {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-s);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.facility-icon {
  font-size: 1.2rem;
}

.facility-name {
  font-size: 0.9rem;
  flex: 1;
}

.facility-level {
  font-weight: bold;
  font-size: 0.9rem;
}

.stable-actions {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-s);
}

.upgrade-facilities-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-s);
}

.facility-upgrade-btn {
  font-size: 0.8rem;
  padding: var(--spacing-xs) var(--spacing-s);
}

/* Horses Grid */
.horses-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.horse-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
  transition: transform var(--transition-speed);
}

.horse-card:active {
  transform: scale(0.98);
}

.horse-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-s);
}

.horse-rating {
  background-color: var(--accent-color);
  color: white;
  padding: var(--spacing-xs) var(--spacing-s);
  border-radius: var(--border-radius-s);
  font-weight: bold;
}

.horse-status {
  padding: var(--spacing-xs) var(--spacing-s);
  border-radius: var(--border-radius-s);
  text-align: center;
  margin-bottom: var(--spacing-s);
  font-size: 0.9rem;
}

.status-resting {
  background-color: var(--primary-light);
  color: white;
}

.status-racing {
  background-color: var(--info-color);
  color: white;
}

.status-training {
  background-color: var(--accent-color);
  color: white;
}

.status-injured {
  background-color: var(--danger-color);
  color: white;
}

.status-retired {
  background-color: var(--text-light);
  color: white;
}

.horse-info {
  margin-bottom: var(--spacing-s);
}

.horse-stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: var(--spacing-xs);
  margin-bottom: var(--spacing-s);
}

.stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-xs);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.stat-label {
  font-size: 0.8rem;
  color: var(--text-light);
}

.stat-value {
  font-weight: bold;
}

.horse-condition {
  margin-bottom: var(--spacing-s);
}

.condition-bar {
  display: flex;
  align-items: center;
  gap: var(--spacing-s);
  margin-bottom: var(--spacing-xs);
}

.condition-label {
  font-size: 0.9rem;
  width: 60px;
}

.bar-outer {
  flex: 1;
  height: 8px;
  background-color: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
}

.bar-inner {
  height: 100%;
  background-color: var(--primary-color);
  border-radius: 4px;
}

.condition-value {
  font-size: 0.9rem;
  font-weight: bold;
  width: 40px;
  text-align: right;
}

.horse-value {
  text-align: right;
  font-weight: bold;
  color: var(--secondary-dark);
  margin-bottom: var(--spacing-s);
}

.horse-actions {
  display: flex;
  gap: var(--spacing-s);
}

.horse-actions button {
  flex: 1;
  font-size: 0.9rem;
}

.stable-actions-bottom {
  margin-top: var(--spacing-l);
  text-align: center;
}

.stable-actions-bottom button {
  width: 100%;
  max-width: 300px;
  padding: var(--spacing-m);
}

/* Training Modal */
.training-modal .modal-body {
  padding-bottom: var(--spacing-l);
}

.training-type-selector {
  margin-bottom: var(--spacing-m);
}

.training-intensity-selector {
  margin-bottom: var(--spacing-m);
}

.intensity-slider-container {
  margin-top: var(--spacing-s);
}

.intensity-slider-container input {
  width: 100%;
  margin-bottom: var(--spacing-xs);
}

.intensity-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-light);
}

.training-info {
  background-color: #f5f5f5;
  padding: var(--spacing-s);
  border-radius: var(--border-radius-s);
  font-size: 0.9rem;
}

/* Horse Detail Screen */
.horse-detail-container {
  padding-bottom: var(--spacing-xl);
}

.detail-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-m);
}

.back-button {
  background: none;
  font-size: 1.5rem;
  padding: 0;
  margin-right: var(--spacing-m);
}

.horse-profile {
  display: flex;
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.horse-avatar {
  width: 100px;
  height: 100px;
  background-color: var(--secondary-light);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.horse-silhouette {
  width: 80%;
  height: 80%;
  background-color: rgba(0, 0, 0, 0.2);
  mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M90,60c-5-10-15-15-25-15s-15,5-20,5s-10-5-15-5s-10,5-15,10S5,65,5,70s5,10,10,10s10-5,15-5s10,5,15,5s10-5,15-5s10,5,15,5s10-5,15-10S95,70,90,60z"/></svg>');
  mask-repeat: no-repeat;
  mask-position: center;
}

.horse-main-stats {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.main-stat {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-xs) 0;
  border-bottom: 1px solid var(--border-color);
}

.stat-value.rating {
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--primary-color);
}

.horse-attributes, .horse-condition-detail, .horse-preferences, 
.racing-history, .pedigree-section, .market-value {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.attribute-grid {
  display: grid;
  gap: var(--spacing-s);
}

.attribute {
  display: flex;
  align-items: center;
  gap: var(--spacing-s);
}

.attribute-label {
  width: 110px;
}

.attribute-bar {
  flex: 1;
  height: 12px;
  background-color: #e0e0e0;
  border-radius: 6px;
  overflow: hidden;
}

.bar-fill {
  height: 100%;
  background-color: var(--primary-color);
  border-radius: 6px;
}

.attribute-value {
  width: 40px;
  text-align: right;
  font-weight: bold;
}

.condition-bars {
  display: grid;
  gap: var(--spacing-s);
}

.condition-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-s);
}

.preferences-grid {
  display: grid;
  gap: var(--spacing-s);
}

.preference {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-xs) 0;
  border-bottom: 1px solid var(--border-color);
}

.history-stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: var(--spacing-s);
  margin-bottom: var(--spacing-m);
}

.history-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-s);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.race-history-table {
  overflow-x: auto;
}

.race-history-table table {
  width: 100%;
  border-collapse: collapse;
}

.race-history-table th, .race-history-table td {
  padding: var(--spacing-s);
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}

.race-history-table th {
  font-weight: bold;
  color: var(--text-light);
}

.pedigree-info p {
  margin-bottom: var(--spacing-xs);
}

.value-info p {
  margin-bottom: var(--spacing-xs);
}

.horse-actions {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-s);
  margin-top: var(--spacing-l);
}

.horse-actions button {
  flex: 1;
  min-width: 120px;
}

/* Race Screen */
.race-screen-container {
  padding-bottom: var(--spacing-xl);
}

.selected-horse-banner, .no-horse-banner {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
  display: flex;
  flex-direction: column;
  gap: var(--spacing-s);
  align-items: center;
}

.races-list {
  display: grid;
  gap: var(--spacing-m);
}

.race-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  overflow: hidden;
  box-shadow: var(--shadow-small);
}

.race-header {
  padding: var(--spacing-m);
  color: white;
}

.race-header.local {
  background-color: var(--local-race);
}

.race-header.regional {
  background-color: var(--regional-race);
}

.race-header.national {
  background-color: var(--national-race);
}

.race-header.elite {
  background-color: var(--elite-race);
}

.race-header.international {
  background-color: var(--international-race);
}

.race-type {
  font-size: 0.9rem;
  opacity: 0.9;
}

.race-details {
  display: flex;
  padding: var(--spacing-m);
  border-bottom: 1px solid var(--border-color);
}

.race-info, .race-purse {
  flex: 1;
}

.info-label {
  font-weight: bold;
  color: var(--text-light);
}

.race-participants {
  padding: var(--spacing-m);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.race-actions {
  padding: var(--spacing-m);
  display: flex;
  gap: var(--spacing-s);
}

.race-actions button, .already-entered {
  flex: 1;
}

.already-entered {
  text-align: center;
  padding: var(--spacing-s);
  background-color: #e0e0e0;
  border-radius: var(--border-radius-m);
  color: var(--text-light);
}

/* Race Detail Screen */
.race-detail-container {
  padding-bottom: var(--spacing-xl);
}

.race-info-banner {
  background-color: var(--primary-color);
  color: white;
  padding: var(--spacing-m);
  border-radius: var(--border-radius-l);
  margin-bottom: var(--spacing-m);
}

.race-winners {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.winner-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
  position: relative;
  width: 280px;
  text-align: center;
}

.position-badge {
  position: absolute;
  top: -10px;
  left: 50%;
  transform: translateX(-50%);
  padding: var(--spacing-xs) var(--spacing-s);
  border-radius: var(--border-radius-m);
  font-weight: bold;
  box-shadow: var(--shadow-small);
}

.winner-card.first .position-badge {
  background-color: gold;
  color: black;
}

.winner-card.second .position-badge {
  background-color: silver;
  color: black;
}

.winner-card.third .position-badge {
  background-color: #cd7f32; /* bronze */
  color: white;
}

.prize-amount {
  margin-top: var(--spacing-s);
  font-weight: bold;
  color: var(--success-color);
}

.full-results {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
  overflow-x: auto;
}

.results-table {
  width: 100%;
  border-collapse: collapse;
}

.results-table th, .results-table td {
  padding: var(--spacing-s);
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}

.results-table th {
  font-weight: bold;
  color: var(--text-light);
}

.player-horse {
  background-color: rgba(0, 0, 0, 0.05);
}

.player-performance {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.good-result {
  color: var(--success-color);
}

/* Market Screen */
.market-screen-container {
  padding-bottom: var(--spacing-xl);
}

.market-header {
  margin-bottom: var(--spacing-m);
}

.market-stats {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-s);
  margin-top: var(--spacing-xs);
  color: var(--text-light);
  font-size: 0.9rem;
}

.market-controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: var(--spacing-m);
}

.market-horses-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.market-horse-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.horse-price {
  text-align: right;
  font-weight: bold;
  font-size: 1.2rem;
  color: var(--secondary-dark);
  margin: var(--spacing-s) 0;
}

.market-actions {
  display: flex;
  gap: var(--spacing-s);
}

.empty-market {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-l);
  box-shadow: var(--shadow-small);
  text-align: center;
}

.player-listings {
  margin-bottom: var(--spacing-l);
}

.listings-grid {
  display: grid;
  grid-template-columns: repeat(auto + amount.toLocaleString();
}

// Initialize UI when document is ready
document.addEventListener('DOMContentLoaded', () => {
  const game = new GameManager();
  game.initialize();
  
  const ui = new MobileUI(game);
  ui.initializeUI();
  
  // Start game loop
  let lastTime = Date.now();
  const gameSpeed = 1; // 1 in-game day per real second
  
  function gameLoop() {
    const currentTime = Date.now();
    const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
    
    // Calculate in-game time delta
    const gameTimeDelta = deltaTime * gameSpeed;
    
    // Update game state
    game.update(gameTimeDelta);
    
    // Update UI
    ui.update();
    
    lastTime = currentTime;
    
    // Schedule next frame
    requestAnimationFrame(gameLoop);
  }
  
  // Start the loop
  gameLoop();
});      // Apply form and energy factors
      const formFactor = horse.form / 100;
      const energyFactor = horse.energy / 100;
      
      // Apply experience bonus (max 10%)
      const experienceBonus = Math.min(horse.experience / 1000, 0.1);
      
      // Calculate adjusted performance
      let adjustedPerformance = basePerformance * formFactor * energyFactor * 
                              (1 + experienceBonus) * (1 + jockeyBonus) * 
                              trackSuitability * distanceSuitability;
      
      // Apply track, distance, and weather modifiers
      adjustedPerformance *= trackConfig.speedFactor;
      adjustedPerformance *= distanceConfig.speedFactor;
      adjustedPerformance *= weatherConfig.speedFactor;
      
      // Add random variation (-10% to +10%)
      const variation = 0.9 + (Math.random() * 0.2);
      const finalPerformance = adjustedPerformance * variation;
      
      // Calculate race time based on distance and performance
      // Lower is better - this is a simplified calculation
      const raceTimeSeconds = (distanceConfig.distance / finalPerformance) * 10;
      
      results.push({
        horseId: horse.id,
        horseName: horse.name,
        jockeyName: participant.jockeyName,
        playerId: participant.playerId,
        performance: finalPerformance,
        time: raceTimeSeconds,
        position: 0 // Will be set after sorting
      });
    }
    
    // Sort by performance (best first)
    results.sort((a, b) => a.time - b.time);
    
    // Assign positions
    results.forEach((result, index) => {
      result.position = index + 1;
    });
    
    // Calculate prize money
    const prizes = this.calculatePrizes(race.purse, results.length);
    
    // Assign prize money and update horses
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      result.prize = prizes[i] || 0;
      
      // Find the horse and update it
      const horse = horses.find(h => h.id === result.horseId);
      if (horse) {
        // Record race result
        const raceRecord = {
          raceId: race.id,
          raceName: race.name,
          day: race.day,
          position: result.position,
          prize: result.prize,
          distance: race.distanceType,
          track: race.trackType,
          weather: race.weatherType
        };
        
        horse.recordRace(raceRecord);
        horse.inRace = false;
        
        // Award prize money to player if this is their horse
        if (result.playerId === player.name && result.prize > 0) {
          player.addFunds(result.prize);
          
          // Record win if position is 1
          if (result.position === 1) {
            player.recordRaceWon();
          }
        }
      }
    }
    
    // Mark race as completed
    race.completed = true;
    race.results = results;
    
    // Move race to history
    this.raceHistory.push(race);
    
    return results;
  }
  
  calculatePrizes(totalPurse, participants) {
    // Default prize distribution (percentages)
    const distribution = [0.6, 0.25, 0.1, 0.05]; // 1st, 2nd, 3rd, 4th
    
    // Create array with prizes for each position
    const prizes = [];
    
    // Calculate prize for each position
    for (let i = 0; i < participants; i++) {
      if (i < distribution.length) {
        prizes.push(Math.round(totalPurse * distribution[i]));
      } else {
        prizes.push(0); // No prize for positions beyond 4th
      }
    }
    
    return prizes;
  }
  
  scheduleRace(raceData) {
    const race = this.generateRace(raceData.type, raceData.day);
    this.races.push(race);
    
    // Add to calendar
    if (!this.raceCalendar[race.day]) {
      this.raceCalendar[race.day] = [];
    }
    this.raceCalendar[race.day].push(race);
    
    return race;
  }
  
  update(deltaTime) {
    // This could handle race scheduling, updating, etc.
  }
}

// -------------------------------------------------
// ECONOMY MANAGER - Game Economy & Progression
// -------------------------------------------------
class EconomyManager {
  constructor() {
    this.inflationRate = 0.002; // Daily inflation rate (0.2%)
    this.economyHealth = 1.0; // 0.5 to 1.5, affects prices and race purses
    this.marketTrends = {
      stableProperty: 1.0,
      horseBreeding: 1.0,
      racingPurses: 1.0,
      training: 1.0,
      jockeyFees: 1.0
    };
    this.upgradeCostMultipliers = {
      stable: 1.5, // Exponential cost increase for stable upgrades
      training: 1.4, // For training facility upgrades
      breeding: 1.6, // For breeding facility upgrades
      staff: 1.3 // For staff upgrades
    };
    
    // Achievement awards
    this.achievements = {
      firstWin: { name: "First Victory", reward: 5000, reputation: 5 },
      tenWins: { name: "Winning Streak", reward: 15000, reputation: 10 },
      championHorse: { name: "Champion Breeder", reward: 50000, reputation: 25 },
      stableEmpire: { name: "Stable Empire", reward: 100000, reputation: 50 }
    };
  }
  
  calculateUpgradeCost(basePrice, currentLevel, upgradeType) {
    const multiplier = this.upgradeCostMultipliers[upgradeType] || 1.5;
    return Math.round(basePrice * Math.pow(multiplier, currentLevel - 1));
  }
  
  adjustMarketTrends(gameTime) {
    // Adjust market trends every 30 in-game days
    if (Math.floor(gameTime) % 30 === 0) {
      // Generate random market fluctuations
      for (const trend in this.marketTrends) {
        // Random adjustment between -10% and +10%
        const adjustment = 0.9 + (Math.random() * 0.2);
        this.marketTrends[trend] *= adjustment;
        
        // Ensure trends stay within reasonable bounds
        this.marketTrends[trend] = Math.max(0.7, Math.min(1.3, this.marketTrends[trend]));
      }
      
      // Adjust overall economy health (slower changes)
      const economyAdjustment = 0.95 + (Math.random() * 0.1);
      this.economyHealth *= economyAdjustment;
      this.economyHealth = Math.max(0.8, Math.min(1.2, this.economyHealth));
    }
  }
  
  getMarketModifier(category) {
    // Get the current market modifier for a specific category
    const trend = this.marketTrends[category] || 1.0;
    return trend * this.economyHealth;
  }
  
  applyInflation(gameTime) {
    // Compound daily inflation
    const daysPassed = Math.floor(gameTime);
    return Math.pow(1 + this.inflationRate, daysPassed);
  }
  
  calculateHorseValue(horse, gameTime) {
    // Get base market value from horse
    let value = horse.calculateMarketValue();
    
    // Apply market trends for horse breeding
    value *= this.getMarketModifier('horseBreeding');
    
    // Apply inflation over time
    value *= this.applyInflation(gameTime);
    
    return Math.round(value);
  }
  
  calculateRacePurse(baseValue, raceType, gameTime) {
    // Base purse value
    let purse = baseValue;
    
    // Apply racing market trend
    purse *= this.getMarketModifier('racingPurses');
    
    // Apply inflation
    purse *= this.applyInflation(gameTime);
    
    return Math.round(purse);
  }
  
  calculateTrainingCost(basePrice, trainingType, gameTime) {
    // Base training cost
    let cost = basePrice;
    
    // Apply training market trend
    cost *= this.getMarketModifier('training');
    
    // Apply inflation
    cost *= this.applyInflation(gameTime);
    
    return Math.round(cost);
  }
  
  checkAchievements(player) {
    const achievements = [];
    
    // Check for first win
    if (player.stats.racesWon === 1) {
      achievements.push(this.awardAchievement('firstWin', player));
    }
    
    // Check for ten wins
    if (player.stats.racesWon === 10) {
      achievements.push(this.awardAchievement('tenWins', player));
    }
    
    // Check for champion horse (horse with 10+ wins)
    const championHorse = player.horses.find(horse => horse.wins >= 10);
    if (championHorse && !player.hasAchievement('championHorse')) {
      achievements.push(this.awardAchievement('championHorse', player));
    }
    
    // Check for stable empire (3+ stables)
    if (player.stables.length >= 3 && !player.hasAchievement('stableEmpire')) {
      achievements.push(this.awardAchievement('stableEmpire', player));
    }
    
    return achievements;
  }
  
  awardAchievement(achievementId, player) {
    const achievement = this.achievements[achievementId];
    if (!achievement) return null;
    
    // Award money
    if (achievement.reward) {
      player.addFunds(achievement.reward);
    }
    
    // Award reputation
    if (achievement.reputation) {
      player.addReputation(achievement.reputation);
    }
    
    // Record achievement
    player.addAchievement(achievementId);
    
    return {
      id: achievementId,
      name: achievement.name,
      reward: achievement.reward,
      reputation: achievement.reputation
    };
  }
  
  getSponsorshipOffers(player) {
    // Generate sponsorship offers based on player reputation
    const offers = [];
    
    // Only offer sponsorships to players with some reputation
    if (player.reputation < 10) return offers;
    
    // Number and value of offers scales with reputation
    const offerCount = Math.min(3, Math.floor(player.reputation / 20) + 1);
    
    for (let i = 0; i < offerCount; i++) {
      const value = 5000 + (player.reputation * 500) + (Math.random() * 10000);
      
      offers.push({
        id: 'sponsor_' + Date.now() + '_' + i,
        name: this.generateSponsorName(),
        value: Math.round(value),
        duration: 10, // lasts for 10 in-game days
        requirements: {
          racesEntered: Math.floor(Math.random() * 3) + 1,
          minimumPosition: Math.floor(Math.random() * 3) + 1
        }
      });
    }
    
    return offers;
  }
  
  generateSponsorName() {
    const prefixes = ["Royal", "Golden", "Elite", "Premium", "Champion", "Victory"];
    const types = ["Racing", "Equestrian", "Thoroughbred", "Stallion", "Racing Cup"];
    const suffixes = ["Feeds", "Equipment", "Gear", "Supplements", "Apparel", "Stakes"];
    
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const type = types[Math.floor(Math.random() * types.length)];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    
    return `${prefix} ${type} ${suffix}`;
  }
}

// -------------------------------------------------
// MARKET MANAGER - Horse Trading & Marketplace
// -------------------------------------------------
class MarketManager {
  constructor() {
    this.marketHorses = []; // Horses available for purchase
    this.playerListings = []; // Horses listed by players
    this.marketRefreshDays = 7; // Market refreshes every 7 days
    this.lastRefreshDay = 0;
    this.marketFees = {
      listingFee: 500, // Fee to list a horse
      salesTax: 0.05 // 5% tax on sales
    };
    this.horseManager = new HorseManager(); // For generating horses
    this.economyManager = new EconomyManager(); // For pricing
  }
  
  refreshMarket(gameTime = 0, playerLevel = 1) {
    // Clear previous market horses
    this.marketHorses = [];
    
    // Number of horses scales with player level
    const horseCount = 5 + Math.floor(playerLevel / 2);
    
    // Generate new market horses with varying quality
    for (let i = 0; i < horseCount; i++) {
      // Calculate quality level - mostly average with some better options
      let qualityLevel = 1;
      
      const roll = Math.random();
      if (roll > 0.9) {
        qualityLevel = Math.min(5, playerLevel + 1); // Excellent quality
      } else if (roll > 0.7) {
        qualityLevel = Math.min(4, playerLevel); // Good quality
      } else if (roll > 0.4) {
        qualityLevel = Math.min(3, Math.max(1, playerLevel - 1)); // Average quality
      } else {
        qualityLevel = Math.max(1, playerLevel - 2); // Lower quality
      }
      
      // Generate a single horse of appropriate quality
      const horse = this.horseManager.generateMarketHorses(1, qualityLevel)[0];
      
      // Apply market pricing
      horse.marketValue = this.economyManager.calculateHorseValue(horse, gameTime);
      horse.purchasePrice = horse.marketValue;
      
      this.marketHorses.push(horse);
    }
    
    this.lastRefreshDay = Math.floor(gameTime);
    return this.marketHorses;
  }
  
  getAvailableHorses() {
    // Combine market horses and player listings
    return [...this.marketHorses, ...this.playerListings];
  }
  
  buyHorse(horse, player) {
    // Check if player has enough funds
    if (player.funds < horse.purchasePrice) {
      return { success: false, message: "Insufficient funds" };
    }
    
    // Check if the horse is still available
    const marketIndex = this.marketHorses.findIndex(h => h.id === horse.id);
    const listingIndex = this.playerListings.findIndex(h => h.id === horse.id);
    
    if (marketIndex === -1 && listingIndex === -1) {
      return { success: false, message: "Horse is no longer available" };
    }
    
    // Process the purchase
    player.removeFunds(horse.purchasePrice);
    
    // If buying from player listing, pay the seller
    if (listingIndex !== -1) {
      const listing = this.playerListings[listingIndex];
      const sellerPayment = Math.round(horse.purchasePrice * (1 - this.marketFees.salesTax));
      
      // In a real game, we'd add funds to the seller player
      // But here we'll just remove from listings
      this.playerListings.splice(listingIndex, 1);
    } else {
      // Remove from market horses
      this.marketHorses.splice(marketIndex, 1);
    }
    
    // Add horse to player's collection
    horse.forSale = false;
    horse.purchasePrice = horse.marketValue;
    player.addHorse(horse);
    
    return { success: true, message: "Purchase successful", horse: horse };
  }
  
  sellHorse(horse, price, player) {
    // Check if player owns the horse
    const playerHorse = player.horses.find(h => h.id === horse.id);
    if (!playerHorse) {
      return { success: false, message: "You don't own this horse" };
    }
    
    // Check if horse is eligible for sale
    if (playerHorse.inRace || playerHorse.inTraining) {
      return { success: false, message: "Horse is racing or in training" };
    }
    
    // Check if player can afford listing fee
    if (player.funds < this.marketFees.listingFee) {
      return { success: false, message: "Insufficient funds for listing fee" };
    }
    
    // Charge listing fee
    player.removeFunds(this.marketFees.listingFee);
    
    // Remove horse from player
    player.removeHorse(horse.id);
    
    // Set sale price and mark for sale
    horse.forSale = true;
    horse.purchasePrice = price;
    
    // Add to player listings
    this.playerListings.push({
      ...horse,
      sellerId: player.id,
      sellerName: player.name,
      listingDate: Date.now()
    });
    
    // Record the sale in player stats
    player.recordHorseSold();
    
    return { success: true, message: "Horse listed for sale", listingFee: this.marketFees.listingFee };
  }
  
  cancelListing(horseId, player) {
    // Find the listing
    const listingIndex = this.playerListings.findIndex(h => h.id === horseId && h.sellerId === player.id);
    
    if (listingIndex === -1) {
      return { success: false, message: "Listing not found" };
    }
    
    // Get the horse from listings
    const horse = this.playerListings[listingIndex];
    
    // Remove from listings
    this.playerListings.splice(listingIndex, 1);
    
    // Return horse to player
    horse.forSale = false;
    player.addHorse(horse);
    
    return { success: true, message: "Listing canceled" };
  }
  
  getMarketTrends(gameTime) {
    // Return current market trends (prices, demand, etc.)
    return {
      averagePrice: this.calculateAverageMarketPrice(),
      highestValue: this.getHighestValueHorse(),
      listingCount: this.playerListings.length,
      marketSize: this.marketHorses.length,
      nextRefresh: this.lastRefreshDay + this.marketRefreshDays - Math.floor(gameTime)
    };
  }
  
  calculateAverageMarketPrice() {
    const allHorses = [...this.marketHorses, ...this.playerListings];
    if (allHorses.length === 0) return 0;
    
    const totalValue = allHorses.reduce((sum, horse) => sum + horse.purchasePrice, 0);
    return Math.round(totalValue / allHorses.length);
  }
  
  getHighestValueHorse() {
    const allHorses = [...this.marketHorses, ...this.playerListings];
    if (allHorses.length === 0) return null;
    
    return allHorses.reduce((highest, horse) => 
      (horse.purchasePrice > highest.purchasePrice) ? horse : highest
    );
  }
  
  specialMarketEvent(eventData) {
    switch (eventData.type) {
      case 'sale':
        // Apply discount to all market horses
        this.marketHorses.forEach(horse => {
          horse.purchasePrice = Math.round(horse.marketValue * 0.8); // 20% off
        });
        break;
      case 'premium':
        // Add special premium horses to the market
        const premiumHorses = this.horseManager.generateMarketHorses(eventData.count || 3, eventData.quality || 5);
        premiumHorses.forEach(horse => {
          horse.marketValue = horse.calculateMarketValue() * 1.2; // Premium pricing
          horse.purchasePrice = horse.marketValue;
        });
        this.marketHorses.push(...premiumHorses);
        break;
      case 'auction':
        // In a real implementation, this would set up a special auction
        // with bidding mechanics
        break;
    }
  }
  
  update(gameTime) {
    // Check if it's time to refresh the market
    const currentDay = Math.floor(gameTime);
    if (currentDay >= this.lastRefreshDay + this.marketRefreshDays) {
      this.refreshMarket(gameTime);
    }
  }
}

// -------------------------------------------------
// EVENT MANAGER - Game Events & Challenges
// -------------------------------------------------
class EventManager {
  constructor() {
    this.events = []; // Scheduled events
    this.activeEvents = []; // Currently active events
    this.eventTypes = {
      race: { name: "Special Race", duration: 3 }, // Special race event
      sale: { name: "Market Sale", duration: 5 }, // Discount on market horses
      challenge: { name: "Racing Challenge", duration: 7 }, // Special racing challenge
      breeding: { name: "Breeding Season", duration: 10 }, // Increased breeding success
      tournament: { name: "Tournament", duration: 14 } // Series of connected races
    };
    
    // Challenge templates
    this.challengeTemplates = [
      {
        id: "rookie_challenge",
        name: "Rookie Challenge",
        description: "Win 3 local races with a horse under training level 5",
        requirement: { type: "wins", count: 3, raceType: "local", maxTrainingLevel: 5 },
        reward: { money: 10000, reputation: 5 }
      },
      {
        id: "distance_specialist",
        name: "Distance Specialist",
        description: "Win 2 long-distance races with the same horse",
        requirement: { type: "wins", count: 2, distanceType: "long", sameHorse: true },
        reward: { money: 15000, reputation: 10 }
      },
      {
        id: "breeding_master",
        name: "Breeding Master",
        description: "Breed a horse with combined attributes over E rating",
        requirement: { type: "breeding", minimumRating: 85 },
        reward: { money: 25000, reputation: 15 }
      },
      {
        id: "stable_expansion",
        name: "Stable Expansion",
        description: "Own 10 horses across all your stables",
        requirement: { type: "ownership", horses: 10 },
        reward: { money: 20000, reputation: 12 }
      },
      {
        id: "champion_trainer",
        name: "Champion Trainer",
        description: "Train a horse to level 10",
        requirement: { type: "training", level: 10 },
        reward: { money: 30000, reputation: 20 }
      }
    ];
  }
  
  scheduleEvent(eventType, startDay, data = {}) {
    const eventConfig = this.eventTypes[eventType];
    if (!eventConfig) return null;
    
    const event = {
      id: 'event_' + Date.now() + '_' + Math.floor(Math.random() * 1000),
      type: eventType,
      name: data.name || eventConfig.name,
      startDay: startDay,
      duration: data.duration || eventConfig.duration,
      endDay: startDay + (data.duration || eventConfig.duration),
      data: data
    };
    
    this.events.push(event);
    return event;
  }
  
  getEventsForDay(day) {
    return this.events.filter(event => event.startDay <= day && event.endDay >= day);
  }
  
  hasActiveEvent() {
    return this.activeEvents.length > 0;
  }
  
  getActiveEvent() {
    return this.activeEvents.length > 0 ? this.activeEvents[0] : null;
  }
  
  generateChallenge(playerLevel) {
    // Select a challenge appropriate for player level
    const eligibleChallenges = this.challengeTemplates.filter(challenge => 
      !challenge.minLevel || playerLevel >= challenge.minLevel
    );
    
    if (eligibleChallenges.length === 0) return null;
    
    // Randomly select a challenge
    const challenge = eligibleChallenges[Math.floor(Math.random() * eligibleChallenges.length)];
    
    // Clone the challenge and assign a unique ID
    return {
      ...challenge,
      id: challenge.id + '_' + Date.now(),
      startTime: Date.now(),
      completed: false
    };
  }
  
  checkChallengeCompletion(challenge, player, event) {
    if (!challenge || challenge.completed) return false;
    
    switch (challenge.requirement.type) {
      case "wins":
        return this.checkWinsChallenge(challenge, player, event);
      case "breeding":
        return this.checkBreedingChallenge(challenge, player, event);
      case "ownership":
        return this.checkOwnershipChallenge(challenge, player);
      case "training":
        return this.checkTrainingChallenge(challenge, player, event);
      default:
        return false;
    }
  }
  
  checkWinsChallenge(challenge, player, event) {
    // Check if the event is a race win
    if (event.type !== 'raceWin') return false;
    
    // Check race type if specified
    if (challenge.requirement.raceType && event.raceType !== challenge.requirement.raceType) {
      return false;
    }
    
    // Check distance type if specified
    if (challenge.requirement.distanceType && event.distanceType !== challenge.requirement.distanceType) {
      return false;
    }
    
    // Check training level if specified
    if (challenge.requirement.maxTrainingLevel) {
      const horse = player.horses.find(h => h.id === event.horseId);
      if (!horse || horse.trainingLevel > challenge.requirement.maxTrainingLevel) {
        return false;
      }
    }
    
    // Check same horse requirement
    if (challenge.requirement.sameHorse) {
      // Store the horse ID for first win
      if (!challenge.horseId) {
        challenge.horseId = event.horseId;
      } else if (challenge.horseId !== event.horseId) {
        return false; // Different horse
      }
    }
    
    // Increment win counter
    challenge.currentWins = (challenge.currentWins || 0) + 1;
    
    // Check if requirement is met
    return challenge.currentWins >= challenge.requirement.count;
  }
  
  checkBreedingChallenge(challenge, player, event) {
    // Check if the event is a breeding event
    if (event.type !== 'breeding') return false;
    
    // Check the offspring's rating
    const offspring = player.horses.find(h => h.id === event.offspringId);
    if (!offspring) return false;
    
    const rating = offspring.calculateOverallRating();
    return rating >= challenge.requirement.minimumRating;
  }
  
  checkOwnershipChallenge(challenge, player) {
    // Simply check if player owns enough horses
    return player.horses.length >= challenge.requirement.horses;
  }
  
  checkTrainingChallenge(challenge, player, event) {
    // Check if any horse reaches the required training level
    if (event.type !== 'horseLevelUp') return false;
    
    const horse = player.horses.find(h => h.id === event.horseId);
    if (!horse) return false;
    
    return horse.trainingLevel >= challenge.requirement.level;
  }
  
  update(deltaTime, gameTime) {
    const currentDay = Math.floor(gameTime);
    
    // Check for events that should start
    const newActiveEvents = this.events.filter(event => 
      event.startDay === currentDay && !this.activeEvents.includes(event)
    );
    
    // Add new active events
    this.activeEvents.push(...newActiveEvents);
    
    // Remove expired events
    this.activeEvents = this.activeEvents.filter(event => event.endDay >= currentDay);
    
    // Periodically schedule new events
    if (currentDay % 15 === 0) { // Every 15 days
      // Schedule a random event 5-10 days in the future
      const eventTypes = Object.keys(this.eventTypes);
      const randomType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
      const startDay = currentDay + 5 + Math.floor(Math.random() * 6);
      
      this.scheduleEvent(randomType, startDay);
    }
  }
}

// -------------------------------------------------
// BREEDING SYSTEM - Horse Breeding & Genetics
// -------------------------------------------------
class BreedingSystem {
  constructor() {
    this.breedingLog = []; // History of breeding pairs and results
    this.breedingCooldown = 60; // Days before a horse can breed again
    this.gestationPeriod = 30; // Days before foal is born
    this.breedingFees = {
      basic: 5000,
      premium: 15000,
      elite: 50000
    };
    this.pendingOffspring = []; // Offspring waiting to be born
    this.seasonalBonus = 0; // Bonus during breeding season events
    
    // Genetic traits that can be passed down
    this.geneticTraits = [
      { name: "Sprinter", affects: "speed", bonus: 5 },
      { name: "Marathoner", affects: "stamina", bonus: 5 },
      { name: "Agile Mover", affects: "agility", bonus: 5 },
      { name: "Quick Starter", affects: "acceleration", bonus: 5 },
      { name: "Iron Will", affects: "consistency", bonus: 5 },
      { name: "Calm Spirit", affects: "temperament", bonus: 5 }
    ];
  }
  
  canBreed(horse) {
    // Check if horse meets breeding requirements
    return (
      horse.canBreed && // Age and health allow breeding
      !horse.inRace && // Not currently racing
      !horse.injured && // Not injured
      !horse.breedingCooldown // Not on cooldown
    );
  }
  
  breedHorses(sire, dam, player, horseManager) {
    // Check if both horses can breed
    if (!this.canBreed(sire) || !this.canBreed(dam)) {
      return { success: false, message: "One or both horses cannot breed at this time" };
    }
    
    // Check if player has enough funds for basic breeding fee
    if (player.funds < this.breedingFees.basic) {
      return {  age(days) {
    // Convert days to years (simplified - assuming 365 days per year)
    const yearsToAdd = days / 365;
    this.age += yearsToAdd;
    
    // Update breeding eligibility
    this.canBreed = this.age >= 3;
    
    // Check for retirement (based on age and random factor)
    if (this.age > 10 && Math.random() < (this.age - 10) * 0.1) {
      this.retire();
    }
    
    return this.age;
  }
  
  retire() {
    this.retired = true;
    this.inTraining = false;
    this.inRace = false;
    
    // Can still breed but can't race
    return true;
  }
  
  recordRace(raceResult) {
    this.races.push(raceResult);
    
    // Update stats
    if (raceResult.position === 1) {
      this.wins++;
    } else if (raceResult.position <= 3) {
      this.placings++;
    }
    
    // Gain experience
    this.experience += 10;
    
    // Update form based on performance
    if (raceResult.position <= 3) {
      this.form = Math.min(100, this.form + 5);
    } else {
      this.form = Math.max(50, this.form - 3);
    }
    
    // Energy depletion based on race distance
    let energyLoss = 30; // Default for medium races
    if (raceResult.distance === 'short') energyLoss = 20;
    if (raceResult.distance === 'long') energyLoss = 40;
    
    this.energy = Math.max(10, this.energy - energyLoss);
    
    // Update market value after race
    this.marketValue = this.calculateMarketValue();
    this.breedingValue = this.calculateBreedingValue();
    
    return raceResult;
  }
  
  addOffspring(offspringId) {
    this.offspring.push(offspringId);
  }
  
  serialize() {
    return {
      id: this.id,
      name: this.name,
      age: this.age,
      speed: this.speed,
      stamina: this.stamina,
      agility: this.agility,
      acceleration: this.acceleration,
      consistency: this.consistency,
      temperament: this.temperament,
      form: this.form,
      energy: this.energy,
      experience: this.experience,
      preferredDistance: this.preferredDistance,
      preferredSurface: this.preferredSurface,
      preferredWeather: this.preferredWeather,
      trainingLevel: this.trainingLevel,
      trainingProgress: this.trainingProgress,
      pedigree: this.pedigree,
      breedingValue: this.breedingValue,
      offspring: this.offspring,
      breedingCooldown: this.breedingCooldown,
      traits: this.traits,
      races: this.races,
      wins: this.wins,
      placings: this.placings,
      purchasePrice: this.purchasePrice,
      marketValue: this.marketValue,
      forSale: this.forSale,
      inTraining: this.inTraining,
      inRace: this.inRace,
      injured: this.injured,
      injuryTime: this.injuryTime,
      canBreed: this.canBreed,
      retired: this.retired
    };
  }
  
  deserialize(data) {
    this.id = data.id;
    this.name = data.name;
    this.age = data.age;
    this.speed = data.speed;
    this.stamina = data.stamina;
    this.agility = data.agility;
    this.acceleration = data.acceleration;
    this.consistency = data.consistency;
    this.temperament = data.temperament;
    this.form = data.form;
    this.energy = data.energy;
    this.experience = data.experience;
    this.preferredDistance = data.preferredDistance;
    this.preferredSurface = data.preferredSurface;
    this.preferredWeather = data.preferredWeather;
    this.trainingLevel = data.trainingLevel;
    this.trainingProgress = data.trainingProgress;
    this.pedigree = data.pedigree;
    this.breedingValue = data.breedingValue;
    this.offspring = data.offspring;
    this.breedingCooldown = data.breedingCooldown || 0;
    this.traits = data.traits || [];
    this.races = data.races;
    this.wins = data.wins;
    this.placings = data.placings;
    this.purchasePrice = data.purchasePrice;
    this.marketValue = data.marketValue;
    this.forSale = data.forSale;
    this.inTraining = data.inTraining;
    this.inRace = data.inRace;
    this.injured = data.injured;
    this.injuryTime = data.injuryTime;
    this.canBreed = data.canBreed;
    this.retired = data.retired;
  }
}

// -------------------------------------------------
// HORSE MANAGER - Horse Creation & Management
// -------------------------------------------------
class HorseManager {
  constructor() {
    this.horseNames = [
      // Male names
      "Thunder Bolt", "Midnight Express", "Royal Flush", "Storm Runner", "Blazing Speed",
      "Noble Steed", "Gallant Prince", "Diamond King", "Maverick", "Triumph",
      // Female names
      "Mystic Beauty", "Graceful Lady", "Starlight Dancer", "Silk Ribbon", "Sweet Victory",
      "Queen's Jewel", "Elegant Spirit", "Summer Breeze", "Golden Symphony", "Majestic Rose"
    ];
  }
  
  generateHorseName(gender = null) {
    const nameIndex = Math.floor(Math.random() * this.horseNames.length);
    return this.horseNames[nameIndex];
  }
  
  generateStarterHorses(count) {
    const horses = [];
    
    for (let i = 0; i < count; i++) {
      // Generate slightly different starter horses
      const attributes = {
        age: 2,
        speed: 45 + Math.floor(Math.random() * 10),
        stamina: 45 + Math.floor(Math.random() * 10),
        agility: 45 + Math.floor(Math.random() * 10),
        acceleration: 45 + Math.floor(Math.random() * 10),
        consistency: 50 + Math.floor(Math.random() * 10),
        temperament: 50 + Math.floor(Math.random() * 10),
        preferredDistance: ['short', 'medium', 'long'][Math.floor(Math.random() * 3)],
        preferredSurface: ['dirt', 'turf', 'synthetic'][Math.floor(Math.random() * 3)],
        trainingLevel: 1,
        purchasePrice: 5000
      };
      
      const name = this.generateHorseName();
      const horse = new Horse(null, name, attributes);
      
      horses.push(horse);
    }
    
    return horses;
  }
  
  generateMarketHorses(count, qualityLevel) {
    const horses = [];
    
    // Quality affects attribute ranges
    const baseMin = 40 + (qualityLevel * 5);
    const baseMax = 55 + (qualityLevel * 5);
    
    for (let i = 0; i < count; i++) {
      const attributes = {
        age: 2 + Math.floor(Math.random() * 4), // 2-5 years old
        speed: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        stamina: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        agility: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        acceleration: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        consistency: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        temperament: baseMin + Math.floor(Math.random() * (baseMax - baseMin)),
        preferredDistance: ['short', 'medium', 'long'][Math.floor(Math.random() * 3)],
        preferredSurface: ['dirt', 'turf', 'synthetic'][Math.floor(Math.random() * 3)],
        trainingLevel: 1 + Math.floor(Math.random() * qualityLevel)
      };
      
      const name = this.generateHorseName();
      const horse = new Horse(null, name, attributes);
      
      // Set purchase price and make available for sale
      horse.marketValue = horse.calculateMarketValue();
      horse.purchasePrice = horse.marketValue;
      horse.forSale = true;
      
      horses.push(horse);
    }
    
    return horses;
  }
  
  breedHorses(sire, dam) {
    // Check if both parents can breed
    if (!sire.canBreed || !dam.canBreed) {
      return null;
    }
    
    // Generate offspring attributes based on parents
    const attributes = {
      age: 0, // Newborn
      speed: this.inheritAttribute(sire.speed, dam.speed),
      stamina: this.inheritAttribute(sire.stamina, dam.stamina),
      agility: this.inheritAttribute(sire.agility, dam.agility),
      acceleration: this.inheritAttribute(sire.acceleration, dam.acceleration),
      consistency: this.inheritAttribute(sire.consistency, dam.consistency),
      temperament: this.inheritAttribute(sire.temperament, dam.temperament),
      preferredDistance: Math.random() < 0.5 ? sire.preferredDistance : dam.preferredDistance,
      preferredSurface: Math.random() < 0.5 ? sire.preferredSurface : dam.preferredSurface,
      trainingLevel: 1,
      traits: [] // Will be populated by genetic traits
    };
    
    // Generate pedigree
    const generation = Math.max(sire.pedigree.generation, dam.pedigree.generation) + 1;
    const pedigree = {
      sire: sire.id,
      dam: dam.id,
      generation: generation,
      lineage: [
        ...new Set([
          ...(sire.pedigree.lineage || []),
          ...(dam.pedigree.lineage || []),
          sire.id,
          dam.id
        ])
      ]
    };
    
    // Generate name
    const name = this.generateHorseName();
    
    // Create the offspring
    const offspring = new Horse(null, name, attributes, pedigree);
    
    // Record offspring in parents
    sire.addOffspring(offspring.id);
    dam.addOffspring(offspring.id);
    
    return offspring;
  }
  
  inheritAttribute(sireValue, damValue) {
    // Calculate base inheritance (average of parents with random variation)
    const baseValue = (sireValue + damValue) / 2;
    
    // Add random variation (-5 to +5)
    const variation = (Math.random() * 10) - 5;
    
    // Ensure within limits
    return Math.min(100, Math.max(1, Math.round(baseValue + variation)));
  }
  
  ageHorse(horse, days) {
    return horse.age(days);
  }
  
  update(deltaTime) {
    // This could handle global horse-related updates
    // For example, automatic aging based on game time
  }
}

// -------------------------------------------------
// STABLE - Stable Entity
// -------------------------------------------------
class Stable {
  constructor(id, name, size, level = 1) {
    this.id = id || this.generateId();
    this.name = name || "Unnamed Stable";
    this.size = size || 3; // Max number of horses
    this.level = level; // Affects training effectiveness
    this.horses = []; // Horse IDs
    this.staff = []; // Staff IDs
    this.facilities = {
      training: 1, // Training facility level
      breeding: 0, // Breeding facility level (0 = none)
      recovery: 1, // Recovery facility level
      comfort: 1 // Comfort level (affects horse wellbeing)
    };
    this.upgradeCosts = {
      size: 10000, // Base cost to add a stall
      training: 15000, // Base cost to upgrade training
      breeding: 25000, // Base cost to add/upgrade breeding
      recovery: 12000, // Base cost to upgrade recovery
      comfort: 8000 // Base cost to upgrade comfort
    };
    this.dailyUpkeep = 500 + (size * 100); // Daily maintenance cost
  }
  
  generateId() {
    return 'stable_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
  }
  
  addHorse(horse) {
    if (this.horses.length >= this.size) {
      return false; // Stable is full
    }
    
    if (typeof horse === 'object') {
      this.horses.push(horse.id);
    } else {
      this.horses.push(horse); // Assuming it's an ID
    }
    
    return true;
  }
  
  removeHorse(horseId) {
    const index = this.horses.indexOf(horseId);
    if (index >= 0) {
      this.horses.splice(index, 1);
      return true;
    }
    return false;
  }
  
  upgradeSize(player) {
    const cost = this.getUpgradeCost('size');
    
    if (player.funds < cost) {
      return false; // Not enough funds
    }
    
    player.removeFunds(cost);
    this.size += 1;
    
    // Increase upkeep
    this.dailyUpkeep += 100;
    
    // Update cost for next upgrade
    this.upgradeCosts.size = Math.floor(this.upgradeCosts.size * 1.5);
    
    return true;
  }
  
  upgradeFacility(facilityType, player) {
    if (!this.facilities.hasOwnProperty(facilityType)) {
      return false; // Invalid facility
    }
    
    const cost = this.getUpgradeCost(facilityType);
    
    if (player.funds < cost) {
      return false; // Not enough funds
    }
    
    player.removeFunds(cost);
    this.facilities[facilityType] += 1;
    
    // Increase upkeep
    this.dailyUpkeep += 50;
    
    // Update cost for next upgrade
    this.upgradeCosts[facilityType] = Math.floor(this.upgradeCosts[facilityType] * 1.5);
    
    return true;
  }
  
  getUpgradeCost(upgradeType) {
    const baseCost = this.upgradeCosts[upgradeType];
    const currentLevel = upgradeType === 'size' ? this.size : this.facilities[upgradeType];
    
    // Exponential cost increase based on current level
    return Math.floor(baseCost * Math.pow(1.2, currentLevel - 1));
  }
  
  getTrainingBonus() {
    // Calculate training effectiveness bonus based on facility level
    return 1 + (this.facilities.training * 0.1); // +10% per level
  }
  
  getRecoveryBonus() {
    // Calculate recovery rate bonus based on facility level
    return 1 + (this.facilities.recovery * 0.15); // +15% per level
  }
  
  getBreedingBonus() {
    // Calculate breeding success bonus based on facility level
    return this.facilities.breeding * 0.05; // +5% per level
  }
  
  getComfortBonus() {
    // Calculate comfort bonus (affects horse wellbeing)
    return this.facilities.comfort * 0.1; // +10% per level
  }
  
  processDaily(horses, player) {
    // Charge daily upkeep
    player.removeFunds(this.dailyUpkeep);
    
    // Process each horse
    for (const horseId of this.horses) {
      const horse = horses.find(h => h.id === horseId);
      if (horse) {
        // Apply recovery bonus for injured horses
        if (horse.injured) {
          const recoveryDays = 1 * this.getRecoveryBonus();
          horse.recover(recoveryDays);
        }
        
        // Apply comfort bonus for resting horses
        if (!horse.inTraining && !horse.inRace) {
          const restAmount = 1 * this.getComfortBonus();
          horse.rest(restAmount);
        }
      }
    }
  }
  
  serialize() {
    return {
      id: this.id,
      name: this.name,
      size: this.size,
      level: this.level,
      horses: [...this.horses],
      staff: [...this.staff],
      facilities: { ...this.facilities },
      upgradeCosts: { ...this.upgradeCosts },
      dailyUpkeep: this.dailyUpkeep
    };
  }
  
  deserialize(data, horsesArray) {
    this.id = data.id;
    this.name = data.name;
    this.size = data.size;
    this.level = data.level;
    this.horses = [...data.horses];
    this.staff = [...data.staff];
    this.facilities = { ...data.facilities };
    this.upgradeCosts = { ...data.upgradeCosts };
    this.dailyUpkeep = data.dailyUpkeep;
  }
}

// -------------------------------------------------
// STABLE MANAGER - Stable Creation & Management
// -------------------------------------------------
class StableManager {
  constructor() {
    this.stableTypes = [
      { name: "Small Farm", size: 3, level: 1, cost: 10000 },
      { name: "Country Stable", size: 5, level: 2, cost: 25000 },
      { name: "Racing Stable", size: 8, level: 3, cost: 50000 },
      { name: "Elite Facility", size: 12, level: 4, cost: 100000 },
      { name: "Championship Complex", size: 20, level: 5, cost: 250000 }
    ];
  }
  
  createStable(name, level) {
    const type = this.stableTypes[level - 1] || this.stableTypes[0];
    const stable = new Stable(null, name, type.size, level);
    return stable;
  }
  
  expandStable(stable, player) {
    return stable.upgradeSize(player);
  }
  
  upgradeFacility(stable, facilityType, player) {
    return stable.upgradeFacility(facilityType, player);
  }
  
  purchaseNewStable(player, stableType) {
    const type = this.stableTypes[stableType - 1];
    if (!type || player.funds < type.cost) {
      return false;
    }
    
    player.removeFunds(type.cost);
    const newStable = this.createStable(`${player.name}'s ${type.name}`, type.level);
    player.addStable(newStable);
    
    return newStable;
  }
  
  renameStable(stable, newName) {
    stable.name = newName;
    return true;
  }
  
  update(deltaTime, player) {
    // Process daily operations for all stables
    const dayPassed = deltaTime >= 1.0;
    
    if (dayPassed) {
      for (const stable of player.stables) {
        stable.processDaily(player.horses, player);
      }
    }
  }
}

// -------------------------------------------------
// RACE MANAGER - Race Creation & Simulation
// -------------------------------------------------
class RaceManager {
  constructor() {
    this.races = []; // Upcoming races
    this.raceHistory = []; // Past races
    this.raceCalendar = {}; // Calendar of scheduled races by date
    this.raceTypes = {
      local: {
        name: "Local Race",
        entryFee: 500,
        purse: 5000,
        prestige: 1,
        difficulty: 1
      },
      regional: {
        name: "Regional Cup",
        entryFee: 1500,
        purse: 15000,
        prestige: 2,
        difficulty: 2
      },
      national: {
        name: "National Championship",
        entryFee: 5000,
        purse: 50000,
        prestige: 3,
        difficulty: 3
      },
      elite: {
        name: "Elite Cup",
        entryFee: 10000,
        purse: 100000,
        prestige: 4,
        difficulty: 4
      },
      international: {
        name: "International Classic",
        entryFee: 25000,
        purse: 250000,
        prestige: 5,
        difficulty: 5
      }
    };
    
    this.trackTypes = {
      dirt: { name: "Dirt Track", speedFactor: 1.0 },
      turf: { name: "Turf Track", speedFactor: 0.95 },
      synthetic: { name: "Synthetic Track", speedFactor: 1.05 }
    };
    
    this.distances = {
      short: { name: "Sprint", distance: 1200, speedFactor: 1.1, staminaFactor: 0.9 },
      medium: { name: "Mile", distance: 1600, speedFactor: 1.0, staminaFactor: 1.0 },
      long: { name: "Endurance", distance: 2400, speedFactor: 0.9, staminaFactor: 1.1 }
    };
    
    this.weatherTypes = {
      sunny: { name: "Sunny", speedFactor: 1.0 },
      cloudy: { name: "Cloudy", speedFactor: 0.98 },
      rainy: { name: "Rainy", speedFactor: 0.9 },
      muddy: { name: "Muddy", speedFactor: 0.85 },
      hot: { name: "Hot", speedFactor: 0.95 },
      cold: { name: "Cold", speedFactor: 0.97 }
    };
  }
  
  initializeRaceCalendar() {
    // Create a 30-day race calendar with different types of races
    for (let day = 1; day <= 30; day++) {
      let races = [];
      
      // Always have local races available
      races.push(this.generateRace('local', day));
      
      // Regional races every 3 days
      if (day % 3 === 0) {
        races.push(this.generateRace('regional', day));
      }
      
      // National races every 7 days
      if (day % 7 === 0) {
        races.push(this.generateRace('national', day));
      }
      
      // Elite races every 14 days
      if (day % 14 === 0) {
        races.push(this.generateRace('elite', day));
      }
      
      // International race once a month
      if (day === 28) {
        races.push(this.generateRace('international', day));
      }
      
      this.raceCalendar[day] = races;
    }
    
    return this.raceCalendar;
  }
  
  generateRace(raceType, day) {
    // Get race type configuration
    const typeConfig = this.raceTypes[raceType];
    
    // Select random track type
    const trackTypes = Object.keys(this.trackTypes);
    const trackType = trackTypes[Math.floor(Math.random() * trackTypes.length)];
    
    // Select random distance
    const distanceTypes = Object.keys(this.distances);
    const distanceType = distanceTypes[Math.floor(Math.random() * distanceTypes.length)];
    
    // Select random weather
    const weatherTypes = Object.keys(this.weatherTypes);
    const weatherType = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
    
    // Generate a unique race ID
    const raceId = 'race_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Create race object
    const race = {
      id: raceId,
      name: this.generateRaceName(raceType, trackType, distanceType),
      type: raceType,
      day: day,
      trackType: trackType,
      distanceType: distanceType,
      weatherType: weatherType,
      entryFee: typeConfig.entryFee,
      purse: typeConfig.purse,
      prestige: typeConfig.prestige,
      difficulty: typeConfig.difficulty,
      participants: [], // Will be populated when horses enter
      results: null, // Will be populated after race is run
      completed: false
    };
    
    return race;
  }
  
  generateRaceName(raceType, trackType, distanceType) {
    const prefixes = [
      "Golden", "Silver", "Royal", "Champion's", "Victory", 
      "Prestigious", "Grand", "Majestic", "Classic", "Elite"
    ];
    
    const suffixes = [
      "Cup", "Stakes", "Derby", "Invitational", "Challenge", 
      "Trophy", "Championship", "Crown", "Prix", "Handicap"
    ];
    
    const trackPrefix = this.trackTypes[trackType].name.split(' ')[0];
    const distancePrefix = this.distances[distanceType].name;
    const racePrefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const raceSuffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    
    return `${racePrefix} ${trackPrefix} ${distancePrefix} ${raceSuffix}`;
  }
  
  getAvailableRaces(day) {
    // Get races for a specific day
    return this.raceCalendar[day % 30 || 30] || [];
  }
  
  enterRace(race, horse, jockey, player) {
    // Check if horse is eligible
    if (horse.injured || horse.inRace || horse.retired) {
      return { success: false, message: "Horse is not eligible to race" };
    }
    
    // Check if player has enough funds for entry fee
    if (player.funds < race.entryFee) {
      return { success: false, message: "Insufficient funds for entry fee" };
    }
    
    // Charge entry fee
    player.removeFunds(race.entryFee);
    
    // Mark horse as in race
    horse.inRace = true;
    
    // Add horse to race participants
    race.participants.push({
      horseId: horse.id,
      horseName: horse.name,
      jockeyId: jockey ? jockey.id : null,
      jockeyName: jockey ? jockey.name : "House Jockey",
      playerId: player.name,
      odds: this.calculateOdds(horse, race)
    });
    
    // Record that player entered a race
    player.recordRaceEntered();
    
    return { success: true, message: "Successfully entered race" };
  }
  
  calculateOdds(horse, race) {
    // Calculate base odds based on horse's overall rating
    const overallRating = horse.calculateOverallRating();
    
    // Track preference adjustment
    let trackPreference = 1.0;
    if (horse.preferredSurface === race.trackType) {
      trackPreference = 1.1; // 10% boost if preferred track
    }
    
    // Distance preference adjustment
    let distancePreference = 1.0;
    if (horse.preferredDistance === race.distanceType) {
      distancePreference = 1.1; // 10% boost if preferred distance
    }
    
    // Calculate effective rating with preferences
    const effectiveRating = overallRating * trackPreference * distancePreference;
    
    // Calculate odds (lower rating = higher odds)
    // Base odds will range from about 2-1 (best horses) to 50-1 (worst horses)
    const baseOdds = Math.max(2, Math.round((100 - effectiveRating) / 2));
    
    // Adjust for race difficulty
    const difficultyAdjustment = 0.8 + (race.difficulty * 0.2);
    const finalOdds = Math.round(baseOdds * difficultyAdjustment);
    
    return finalOdds;
  }
  
  simulateRace(race, horses, player) {
    if (race.completed) {
      return race.results;
    }
    
    // Get all horses in the race
    const raceHorses = race.participants.map(participant => {
      const horse = horses.find(h => h.id === participant.horseId);
      return {
        participant: participant,
        horse: horse
      };
    });
    
    // Get track configuration
    const trackConfig = this.trackTypes[race.trackType];
    const distanceConfig = this.distances[race.distanceType];
    const weatherConfig = this.weatherTypes[race.weatherType];
    
    // Prepare results array
    const results = [];
    
    // Simulate each horse's performance
    for (const { participant, horse } of raceHorses) {
      // Calculate jockey skill bonus (0-10%)
      const jockeyBonus = participant.jockeyId ? 0.1 : 0; // Simplified - would come from jockey object
      
      // Calculate track suitability
      const trackSuitability = horse.preferredSurface === race.trackType ? 1.1 : 1.0;
      
      // Calculate distance suitability
      const distanceSuitability = horse.preferredDistance === race.distanceType ? 1.1 : 1.0;
      
      // Calculate base performance from horse attributes
      let basePerformance = 0;
      
      // Sprint race emphasizes speed and acceleration
      if (race.distanceType === 'short') {
        basePerformance = (horse.speed * 0.4) + (horse.acceleration * 0.3) + 
                          (horse.stamina * 0.1) + (horse.agility * 0.2);
      }
      // Medium race is balanced
      else if (race.distanceType === 'medium') {
        basePerformance = (horse.speed * 0.3) + (horse.acceleration * 0.2) + 
                          (horse.stamina * 0.3) + (horse.agility * 0.2);
      }
      // Long race emphasizes stamina
      else {
        basePerformance = (horse.speed * 0.2) + (horse.acceleration * 0.1) + 
                          (horse.stamina * 0.5) + (horse.agility * 0.2);
      }
      
      // Apply form and energy.listings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-m);
}

.listing-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  gap: var(--spacing-s);
}

/* Breeding Screen */
.breeding-screen-container {
  padding-bottom: var(--spacing-xl);
}

.breeding-stats-panel {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-s);
}

.stat-item {
  display: flex;
  flex-direction: column;
  padding: var(--spacing-s);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.breeding-form {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.selection-container {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-m);
}

@media (min-width: 480px) {
  .selection-container {
    grid-template-columns: 1fr 1fr;
  }
}

.breeding-details {
  background-color: #f5f5f5;
  padding: var(--spacing-s);
  border-radius: var(--border-radius-s);
  margin-bottom: var(--spacing-m);
}

.no-breeding-horses {
  background-color: #f5f5f5;
  padding: var(--spacing-s);
  border-radius: var(--border-radius-s);
  text-align: center;
}

.pending-births {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.births-list {
  display: grid;
  gap: var(--spacing-s);
}

.birth-item {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-s);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.breeding-advice {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.breeding-advice ul {
  padding-left: var(--spacing-l);
}

.breeding-advice li {
  margin-bottom: var(--spacing-xs);
}

/* Settings Screen */
.settings-screen-container {
  padding-bottom: var(--spacing-xl);
}

.settings-section {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.setting-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-s) 0;
  border-bottom: 1px solid var(--border-color);
}

.setting-item:last-child {
  border-bottom: none;
}

.setting-control {
  min-width: 100px;
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 24px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .toggle-slider {
  background-color: var(--primary-color);
}

input:checked + .toggle-slider:before {
  transform: translateX(26px);
}

.save-load-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-s);
}

.save-load-buttons button {
  flex: 1;
}

.about-info {
  text-align: center;
}

#back-to-game-btn {
  display: block;
  margin: 0 auto;
  width: 100%;
  max-width: 300px;
  padding: var(--spacing-m);
}

/* Responsive Adjustments */
@media (max-width: 480px) {
  .facility-levels {
    grid-template-columns: 1fr;
  }
  
  .upgrade-facilities-container {
    grid-template-columns: 1fr;
  }
  
  .horse-stats {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .race-details {
    flex-direction: column;
  }
  
  .race-actions {
    flex-direction: column;
  }
  
  .winner-card {
    width: 100%;
  }
  
  .stats-grid {
    grid-template-columns: 1fr;
  }
}

/* Animations */
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.pulse {
  animation: pulse 2s infinite;
}

/* Loading Indicator */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 5px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: white;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Utils */
.text-center {
  text-align: center;
}

.mb-0 {
  margin-bottom: 0;
}

.hidden {
  display: none;
}

.truncate {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Will be populated by MobileUI -->
    </div>

    <script>
// -------------------------------------------------
// GAME MANAGER - Central Control System
// -------------------------------------------------
class GameManager {
  constructor() {
    this.player = new Player();
    this.horseManager = new HorseManager();
    this.stableManager = new StableManager();
    this.raceManager = new RaceManager();
    this.economyManager = new EconomyManager();
    this.eventManager = new EventManager();
    this.marketManager = new MarketManager();
    this.breedingSystem = new BreedingSystem();
    this.initialized = false;
    
    // Game state
    this.currentScreen = 'mainMenu'; // mainMenu, stable, race, market, breeding, etc.
    this.gameTime = 0; // In-game time tracker (days)
  }
  
  initialize() {
    // Set up initial game state
    this.player.initialize("Player", 10000); // Starting with $10,000
    
    // Create initial stable with one starter horse
    const starterStable = this.stableManager.createStable("Your First Stable", 1);
    this.player.addStable(starterStable);
    
    // Generate starter horse options
    const starterHorses = this.horseManager.generateStarterHorses(3);
    
    // Add first horse to player's stable
    this.player.addHorse(starterHorses[0]);
    
    // Initialize race calendar
    this.raceManager.initializeRaceCalendar();
    
    // Initialize market with some horses
    this.marketManager.refreshMarket();
    
    this.initialized = true;
    console.log("Game initialized successfully!");
  }
  
  update(deltaTime) {
    // Main game loop - update all systems
    if (!this.initialized) return;
    
    // Update in-game time
    this.gameTime += deltaTime;
    
    // Update managers
    this.raceManager.update(deltaTime);
    this.stableManager.update(deltaTime, this.player);
    this.horseManager.update(deltaTime);
    this.eventManager.update(deltaTime, this.gameTime);
    this.breedingSystem.update(deltaTime, this.gameTime, this.player, this.horseManager);
    this.marketManager.update(this.gameTime);
    this.economyManager.adjustMarketTrends(this.gameTime);
    
    // Check for scheduled events
    if (this.eventManager.hasActiveEvent()) {
      const activeEvent = this.eventManager.getActiveEvent();
      this.handleEvent(activeEvent);
    }
    
    // Refresh market periodically
    if (Math.floor(this.gameTime) % 7 === 0 && Math.floor(this.gameTime) !== Math.floor(this.gameTime - deltaTime)) {
      this.marketManager.refreshMarket(this.gameTime, Math.max(1, Math.floor(this.player.reputation / 10)));
    }
    
    // Check for achievements
    this.economyManager.checkAchievements(this.player);
  }
  
  handleEvent(event) {
    // Process active events
    switch(event.type) {
      case 'race':
        this.raceManager.scheduleRace(event.data);
        break;
      case 'market':
        this.marketManager.specialMarketEvent(event.data);
        break;
      case 'challenge':
        this.player.addChallenge(event.data);
        break;
      case 'breeding':
        // Apply breeding season bonuses
        this.breedingSystem.seasonalBonus = 0.2; // 20% bonus to breeding success
        break;
      default:
        console.log(`Unknown event type: ${event.type}`);
    }
  }
  
  changeScreen(screen) {
    this.currentScreen = screen;
    // Trigger UI update
    console.log(`Screen changed to: ${screen}`);
  }
  
  save() {
    // Save game state to local storage
    const gameState = {
      player: this.player.serialize(),
      gameTime: this.gameTime,
      breedingSystem: {
        pendingOffspring: this.breedingSystem.pendingOffspring.map(offspring => ({
          sireId: offspring.sire.id,
          damId: offspring.dam.id,
          birthDay: offspring.birthDay,
          traits: offspring.traits
        })),
        breedingLog: this.breedingSystem.breedingLog
      },
      marketManager: {
        marketHorses: this.marketManager.marketHorses.map(horse => horse.serialize()),
        playerListings: this.marketManager.playerListings.map(horse => horse.serialize()),
        lastRefreshDay: this.marketManager.lastRefreshDay
      },
      raceManager: {
        races: this.raceManager.races,
        raceHistory: this.raceManager.raceHistory
      },
      eventManager: {
        events: this.eventManager.events,
        activeEvents: this.eventManager.activeEvents
      }
    };
    
    localStorage.setItem('equineEmpireSave', JSON.stringify(gameState));
    console.log("Game saved successfully!");
    return true;
  }
  
  load() {
    // Load game state from local storage
    const savedState = localStorage.getItem('equineEmpireSave');
    if (!savedState) {
      console.log("No saved game found.");
      return false;
    }
    
    try {
      const gameState = JSON.parse(savedState);
      
      // Load player data
      this.player.deserialize(gameState.player);
      
      // Load game time
      this.gameTime = gameState.gameTime;
      
      // Load breeding system data
      if (gameState.breedingSystem) {
        // We need to convert the serialized offspring data back to full objects
        this.breedingSystem.pendingOffspring = gameState.breedingSystem.pendingOffspring.map(offspringData => {
          const sire = this.player.horses.find(h => h.id === offspringData.sireId);
          const dam = this.player.horses.find(h => h.id === offspringData.damId);
          
          if (sire && dam) {
            return {
              sire: sire,
              dam: dam,
              birthDay: offspringData.birthDay,
              traits: offspringData.traits
            };
          }
          return null;
        }).filter(offspring => offspring !== null);
        
        this.breedingSystem.breedingLog = gameState.breedingSystem.breedingLog;
      }
      
      // Load market data
      if (gameState.marketManager) {
        // Convert serialized horses back to Horse objects
        this.marketManager.marketHorses = gameState.marketManager.marketHorses.map(horseData => {
          const horse = new Horse();
          horse.deserialize(horseData);
          return horse;
        });
        
        this.marketManager.playerListings = gameState.marketManager.playerListings.map(horseData => {
          const horse = new Horse();
          horse.deserialize(horseData);
          return horse;
        });
        
        this.marketManager.lastRefreshDay = gameState.marketManager.lastRefreshDay;
      }
      
      // Load race data
      if (gameState.raceManager) {
        this.raceManager.races = gameState.raceManager.races;
        this.raceManager.raceHistory = gameState.raceManager.raceHistory;
      }
      
      // Load event data
      if (gameState.eventManager) {
        this.eventManager.events = gameState.eventManager.events;
        this.eventManager.activeEvents = gameState.eventManager.activeEvents;
      }
      
      this.initialized = true;
      console.log("Game loaded successfully!");
      return true;
    } catch (error) {
      console.error("Error loading saved game:", error);
      return false;
    }
  }
}

// -------------------------------------------------
// PLAYER - Player Data & Progression
// -------------------------------------------------
class Player {
  constructor() {
    this.name = "";
    this.funds = 0;
    this.stables = [];
    this.horses = [];
    this.reputation = 0;
    this.trophies = [];
    this.challenges = [];
    this.achievements = [];
    this.stats = {
      racesEntered: 0,
      racesWon: 0,
      horsesBred: 0,
      horsesSold: 0,
      totalEarnings: 0
    };
  }
  
  initialize(name, startingFunds) {
    this.name = name;
    this.funds = startingFunds;
    this.reputation = 1; // Starting reputation level
  }
  
  addFunds(amount) {
    this.funds += amount;
    this.stats.totalEarnings += amount;
    return this.funds;
  }
  
  removeFunds(amount) {
    if (this.funds >= amount) {
      this.funds -= amount;
      return true;
    }
    return false;
  }
  
  addStable(stable) {
    this.stables.push(stable);
  }
  
  addHorse(horse) {
    this.horses.push(horse);
    // Assign to first stable if available
    if (this.stables.length > 0) {
      this.stables[0].addHorse(horse);
    }
  }
  
  removeHorse(horseId) {
    const horseIndex = this.horses.findIndex(h => h.id === horseId);
    if (horseIndex >= 0) {
      // Also remove from stable
      for (const stable of this.stables) {
        stable.removeHorse(horseId);
      }
      
      const removedHorse = this.horses.splice(horseIndex, 1)[0];
      return removedHorse;
    }
    return null;
  }
  
  addReputation(amount) {
    this.reputation += amount;
    return this.reputation;
  }
  
  addTrophy(trophy) {
    this.trophies.push(trophy);
  }
  
  addChallenge(challenge) {
    this.challenges.push(challenge);
  }
  
  completeChallenge(challengeId) {
    const challengeIndex = this.challenges.findIndex(c => c.id === challengeId);
    if (challengeIndex >= 0) {
      const challenge = this.challenges[challengeIndex];
      this.challenges.splice(challengeIndex, 1);
      
      // Apply rewards
      this.addFunds(challenge.rewardMoney || 0);
      this.addReputation(challenge.rewardReputation || 0);
      
      return challenge;
    }
    return null;
  }
  
  addAchievement(achievementId) {
    if (!this.achievements.includes(achievementId)) {
      this.achievements.push(achievementId);
      return true;
    }
    return false;
  }
  
  hasAchievement(achievementId) {
    return this.achievements.includes(achievementId);
  }
  
  recordRaceEntered() {
    this.stats.racesEntered++;
  }
  
  recordRaceWon() {
    this.stats.racesWon++;
  }
  
  recordHorseBred() {
    this.stats.horsesBred++;
  }
  
  recordHorseSold() {
    this.stats.horsesSold++;
  }
  
  getHorseCount() {
    return this.horses.length;
  }
  
  getStableCount() {
    return this.stables.length;
  }
  
  serialize() {
    return {
      name: this.name,
      funds: this.funds,
      stables: this.stables.map(stable => stable.serialize()),
      horses: this.horses.map(horse => horse.serialize()),
      reputation: this.reputation,
      trophies: this.trophies,
      challenges: this.challenges,
      achievements: this.achievements,
      stats: { ...this.stats }
    };
  }
  
  deserialize(data) {
    this.name = data.name;
    this.funds = data.funds;
    this.reputation = data.reputation;
    this.trophies = data.trophies;
    this.challenges = data.challenges;
    this.achievements = data.achievements || [];
    this.stats = { ...data.stats };
    
    // Deserialize horses
    this.horses = data.horses.map(horseData => {
      const horse = new Horse();
      horse.deserialize(horseData);
      return horse;
    });
    
    // Deserialize stables
    this.stables = data.stables.map(stableData => {
      const stable = new Stable();
      stable.deserialize(stableData, this.horses);
      return stable;
    });
  }
}

// -------------------------------------------------
// HORSE - Core Horse Entity
// -------------------------------------------------
class Horse {
  constructor(id, name, attributes = {}, pedigree = null) {
    this.id = id || this.generateId();
    this.name = name || "Unnamed Horse";
    this.age = attributes.age || 2; // Starting age in years
    
    // Core attributes
    this.speed = attributes.speed || 50; // 0-100
    this.stamina = attributes.stamina || 50; // 0-100
    this.agility = attributes.agility || 50; // 0-100
    this.acceleration = attributes.acceleration || 50; // 0-100
    this.consistency = attributes.consistency || 50; // 0-100
    this.temperament = attributes.temperament || 50; // 0-100 (higher = calmer)
    
    // Performance attributes
    this.form = 100; // 0-100, current physical condition
    this.energy = 100; // 0-100, current energy level
    this.experience = 0; // Racing experience, increases with races
    this.preferredDistance = attributes.preferredDistance || 'medium'; // short, medium, long
    this.preferredSurface = attributes.preferredSurface || 'dirt'; // dirt, turf, synthetic
    this.preferredWeather = attributes.preferredWeather || 'sunny'; // sunny, rainy, etc.
    
    // Training and progress
    this.trainingLevel = attributes.trainingLevel || 1;
    this.trainingProgress = 0; // 0-100, progress to next level
    
    // Genetics and breeding
    this.pedigree = pedigree || {
      sire: null, // Father
      dam: null, // Mother
      generation: 1, // Generation number
      lineage: [] // Array of notable ancestors
    };
    this.breedingValue = this.calculateBreedingValue();
    this.offspring = []; // IDs of offspring
    this.breedingCooldown = 0; // Days before can breed again
    this.traits = attributes.traits || [];
    
    // Racing history
    this.races = [];
    this.wins = 0;
    this.placings = 0; // 2nd or 3rd place finishes
    
    // Market info
    this.purchasePrice = attributes.purchasePrice || 5000;
    this.marketValue = this.calculateMarketValue();
    this.forSale = false;
    
    // Status flags
    this.inTraining = false;
    this.inRace = false;
    this.injured = false;
    this.injuryTime = 0; // Days until recovered
    this.canBreed = this.age >= 3; // Can breed at age 3+
    this.retired = false;
  }
  
  generateId() {
    return 'horse_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
  }
  
  calculateOverallRating() {
    // Calculate overall performance rating based on attributes
    const baseRating = (
      this.speed * 0.25 +
      this.stamina * 0.25 +
      this.agility * 0.15 +
      this.acceleration * 0.15 +
      this.consistency * 0.1 +
      this.temperament * 0.1
    );
    
    // Apply form factor
    const formFactor = this.form / 100;
    
    // Apply experience bonus (max 10%)
    const experienceBonus = Math.min(this.experience / 100, 0.1);
    
    return Math.round(baseRating * formFactor * (1 + experienceBonus));
  }
  
  calculateMarketValue() {
    // Base value from attributes
    const attributeValue = (
      this.speed * 300 +
      this.stamina * 250 +
      this.agility * 200 +
      this.acceleration * 200 +
      this.consistency * 150 +
      this.temperament * 100
    );
    
    // Age modifier - value peaks at 4-5 years
    let ageModifier = 1.0;
    if (this.age < 3) ageModifier = 0.8; // Young, unproven
    else if (this.age >= 3 && this.age <= 5) ageModifier = 1.2; // Prime
    else if (this.age > 5 && this.age <= 8) ageModifier = 0.9; // Mature
    else if (this.age > 8) ageModifier = 0.7; // Senior
    
    // Racing record bonus
    const recordBonus = this.wins * 5000 + this.placings * 2000;
    
    // Pedigree bonus
    let pedigreeBonus = 0;
    if (this.pedigree.generation > 1) {
      pedigreeBonus = 10000 * (this.pedigree.generation - 1);
    }
    
    // Calculate final value
    let value = (attributeValue * ageModifier) + recordBonus + pedigreeBonus;
    
    // Minimum value floor
    value = Math.max(value, 2000);
    
    return Math.round(value);
  }
  
  calculateBreedingValue() {
    // Base value from best attributes
    const bestAttributes = Math.max(this.speed, this.stamina, this.agility, this.acceleration);
    
    // Racing success factor
    const racingFactor = 1 + (this.wins * 0.1);
    
    // Pedigree factor
    let pedigreeFactor = 1.0;
    if (this.pedigree.generation > 1) {
      pedigreeFactor = 1.0 + ((this.pedigree.generation - 1) * 0.2);
    }
    
    return Math.round(bestAttributes * racingFactor * pedigreeFactor);
  }
  
  train(trainingType, intensity) {
    // Skip if injured or in race
    if (this.injured || this.inRace) return false;
    
    this.inTraining = true;
    
    // Training effectiveness based on intensity (1-5)
    const effectivenessMultiplier = 0.5 + (intensity * 0.1);
    
    // Energy cost based on intensity
    const energyCost = 5 + (intensity * 3);
    this.energy = Math.max(0, this.energy - energyCost);
    
    // Progress gain based on training type
    let progressGain = 10 * effectivenessMultiplier;
    
    // Different training types improve different attributes
    switch (trainingType) {
      case 'speed':
        this.speed += 0.2 * effectivenessMultiplier;
        break;
      case 'stamina':
        this.stamina += 0.2 * effectivenessMultiplier;
        break;
      case 'agility':
        this.agility += 0.2 * effectivenessMultiplier;
        break;
      case 'acceleration':
        this.acceleration += 0.2 * effectivenessMultiplier;
        break;
      default:
        // General training improves all attributes slightly
        this.speed += 0.05 * effectivenessMultiplier;
        this.stamina += 0.05 * effectivenessMultiplier;
        this.agility += 0.05 * effectivenessMultiplier;
        this.acceleration += 0.05 * effectivenessMultiplier;
    }
    
    // Cap attributes at 100
    this.speed = Math.min(100, this.speed);
    this.stamina = Math.min(100, this.stamina);
    this.agility = Math.min(100, this.agility);
    this.acceleration = Math.min(100, this.acceleration);
    
    // Injury risk based on intensity and current energy
    const injuryRisk = (intensity * 0.5) * (1 - (this.energy / 100));
    if (Math.random() < injuryRisk) {
      this.injury(Math.floor(Math.random() * 10) + 1); // 1-10 days
      return false;
    }
    
    // Update training progress
    this.trainingProgress += progressGain;
    if (this.trainingProgress >= 100) {
      this.levelUp();
    }
    
    // Update market value after training
    this.marketValue = this.calculateMarketValue();
    
    this.inTraining = false;
    return true;
  }
  
  levelUp() {
    this.trainingLevel++;
    this.trainingProgress = 0;
    
    // Bonus improvement on level up
    this.speed += 1;
    this.stamina += 1;
    this.agility += 1;
    this.acceleration += 1;
    
    // Cap attributes at 100
    this.speed = Math.min(100, this.speed);
    this.stamina = Math.min(100, this.stamina);
    this.agility = Math.min(100, this.agility);
    this.acceleration = Math.min(100, this.acceleration);
    
    return this.trainingLevel;
  }
  
  rest(days) {
    // Energy recovery
    this.energy = Math.min(100, this.energy + (days * 15));
    
    // Form improvement if resting
    this.form = Math.min(100, this.form + (days * 5));
    
    return this.energy;
  }
  
  injury(days) {
    this.injured = true;
    this.injuryTime = days;
    this.inTraining = false;
    this.inRace = false;
    
    // Reduce form due to injury
    this.form = Math.max(50, this.form - 20);
    
    return days;
  }
  
  recover(days) {
    if (!this.injured) return 0;
    
    this.injuryTime -= days;
    if (this.injuryTime <= 0) {
      this.injured = false;
      this.injuryTime = 0;
      return 0;
    }
    
    return this.injuryTime;
  }
  
  age(days) {
    // Convert days to years (simplified - assuming 365 days per year)
    const yearsToAdd = days / 365;
    this.age += yearsToAdd;
    
    // Update breeding eligibility
    this.canBreed = this.age >= 3;
    
    // Check for retirement (based on age and random factor)
    if (this.age > 10 && Math.<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Equine Empire: The Racing Tycoon</title>
    <style>
/* ---------------------------------------------------
   EQUINE EMPIRE: THE RACING TYCOON - Mobile CSS
   --------------------------------------------------- */

/* Base Styles */
:root {
  /* Color Palette */
  --primary-color: #2c7a5a;
  --primary-dark: #1c5b3f;
  --primary-light: #3d9b72;
  --secondary-color: #8a572f;
  --secondary-dark: #664022;
  --secondary-light: #aa7349;
  --accent-color: #d3a157;
  --accent-dark: #b88a3f;
  --accent-light: #e2ba76;
  
  /* UI Colors */
  --background-color: #f8f5f1;
  --card-background: #ffffff;
  --text-color: #333333;
  --text-light: #666666;
  --text-inverse: #ffffff;
  --border-color: #e0e0e0;
  --success-color: #4caf50;
  --warning-color: #ff9800;
  --danger-color: #f44336;
  --info-color: #2196f3;
  
  /* Race Types Colors */
  --local-race: #8bc34a;
  --regional-race: #03a9f4;
  --national-race: #9c27b0;
  --elite-race: #ff9800;
  --international-race: #d32f2f;
  
  /* Typography */
  --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  --heading-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  
  /* Spacing */
  --spacing-xs: 4px;
  --spacing-s: 8px;
  --spacing-m: 16px;
  --spacing-l: 24px;
  --spacing-xl: 32px;
  
  /* Borders */
  --border-radius-s: 4px;
  --border-radius-m: 8px;
  --border-radius-l: 12px;
  --border-radius-xl: 20px;
  
  /* Shadows */
  --shadow-small: 0 2px 4px rgba(0,0,0,0.1);
  --shadow-medium: 0 4px 8px rgba(0,0,0,0.1);
  --shadow-large: 0 8px 16px rgba(0,0,0,0.1);
  
  /* Animations */
  --transition-speed: 0.3s;
}

/* Dark Mode Colors */
.dark-mode {
  --background-color: #222;
  --card-background: #333;
  --text-color: #f0f0f0;
  --text-light: #aaa;
  --border-color: #444;
}

/* Base Elements */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  font-family: var(--font-family);
  font-size: 16px;
  line-height: 1.5;
  color: var(--text-color);
  background-color: var(--background-color);
  height: 100%;
  width: 100%;
  overflow-x: hidden;
}

h1, h2, h3, h4, h5, h6 {
  font-family: var(--heading-font);
  margin-bottom: var(--spacing-m);
  font-weight: 600;
}

h1 {
  font-size: 2.5rem;
}

h2 {
  font-size: 2rem;
}

h3 {
  font-size: 1.5rem;
}

h4 {
  font-size: 1.25rem;
}

p {
  margin-bottom: var(--spacing-m);
}

button {
  font-family: var(--font-family);
  cursor: pointer;
  border: none;
  outline: none;
  padding: var(--spacing-s) var(--spacing-m);
  border-radius: var(--border-radius-m);
  font-weight: 500;
  transition: background-color var(--transition-speed), transform var(--transition-speed);
}

button:active {
  transform: scale(0.98);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background-color: var(--primary-color);
  color: white;
}

.btn-primary:hover {
  background-color: var(--primary-dark);
}

.btn-secondary {
  background-color: var(--secondary-color);
  color: white;
}

.btn-secondary:hover {
  background-color: var(--secondary-dark);
}

.btn-danger {
  background-color: var(--danger-color);
  color: white;
}

.btn-danger:hover {
  background-color: #d32f2f;
}

/* Game Container */
#game-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  max-width: 600px;
  margin: 0 auto;
  position: relative;
}

/* Player Info Bar */
#player-info-bar {
  background-color: var(--primary-color);
  color: white;
  padding: var(--spacing-s) var(--spacing-m);
  position: sticky;
  top: 0;
  z-index: 100;
}

.player-info-content {
  display: flex;
  justify-content: space-between;
}

.player-funds {
  font-weight: bold;
}

/* Screens Container */
#screens-container {
  flex: 1;
  overflow-y: auto;
  padding-bottom: 60px; /* Space for bottom nav */
}

.game-screen {
  padding: var(--spacing-m);
}

/* Bottom Navigation */
#bottom-navigation {
  background-color: var(--card-background);
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: space-around;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 60px;
  max-width: 600px;
  margin: 0 auto;
  z-index: 100;
}

.nav-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: none;
  color: var(--text-light);
  flex: 1;
  padding: var(--spacing-xs);
}

.nav-button.active {
  color: var(--primary-color);
}

.nav-icon {
  font-size: 1.5rem;
  margin-bottom: var(--spacing-xs);
}

.nav-label {
  font-size: 0.75rem;
}

/* Message Container */
#message-container {
  position: fixed;
  top: 70px;
  left: 0;
  right: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  z-index: 1000;
}

.message {
  background-color: var(--primary-color);
  color: white;
  padding: var(--spacing-s) var(--spacing-m);
  border-radius: var(--border-radius-m);
  margin-bottom: var(--spacing-s);
  box-shadow: var(--shadow-medium);
  max-width: 80%;
  text-align: center;
  animation: slide-in 0.3s ease-out;
}

.message.fade-out {
  animation: fade-out 0.5s ease-out forwards;
}

@keyframes slide-in {
  from { transform: translateY(-20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes fade-out {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: var(--shadow-large);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-m);
  border-bottom: 1px solid var(--border-color);
}

.modal-header h3 {
  margin: 0;
}

.close-modal {
  background: none;
  font-size: 1.5rem;
  color: var(--text-light);
  padding: 0;
}

.modal-body {
  padding: var(--spacing-m);
}

.modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-m);
  padding: var(--spacing-m);
  border-top: 1px solid var(--border-color);
}

/* Main Menu Screen */
.main-menu-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xl) var(--spacing-m);
  min-height: 80vh;
}

.game-logo {
  text-align: center;
  margin-bottom: var(--spacing-xl);
}

.game-logo h1 {
  color: var(--primary-color);
  font-size: 2.5rem;
  margin-bottom: var(--spacing-xs);
}

.game-logo h2 {
  color: var(--secondary-color);
  font-size: 1.5rem;
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-m);
  width: 80%;
}

.menu-buttons button {
  padding: var(--spacing-m);
  font-size: 1.2rem;
}

/* Stable Screen */
.stable-screen-container {
  padding-bottom: var(--spacing-xl);
}

.stables-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.stable-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.stable-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-m);
}

.stable-level {
  background-color: var(--primary-light);
  color: white;
  padding: var(--spacing-xs) var(--spacing-s);
  border-radius: var(--border-radius-s);
  font-size: 0.9rem;
}

.stable-info {
  margin-bottom: var(--spacing-m);
}

.facility-levels {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-s);
  margin-bottom: var(--spacing-m);
}

.facility {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-s);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.facility-icon {
  font-size: 1.2rem;
}

.facility-name {
  font-size: 0.9rem;
  flex: 1;
}

.facility-level {
  font-weight: bold;
  font-size: 0.9rem;
}

.stable-actions {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-s);
}

.upgrade-facilities-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--spacing-s);
}

.facility-upgrade-btn {
  font-size: 0.8rem;
  padding: var(--spacing-xs) var(--spacing-s);
}

/* Horses Grid */
.horses-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.horse-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
  transition: transform var(--transition-speed);
}

.horse-card:active {
  transform: scale(0.98);
}

.horse-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-s);
}

.horse-rating {
  background-color: var(--accent-color);
  color: white;
  padding: var(--spacing-xs) var(--spacing-s);
  border-radius: var(--border-radius-s);
  font-weight: bold;
}

.horse-status {
  padding: var(--spacing-xs) var(--spacing-s);
  border-radius: var(--border-radius-s);
  text-align: center;
  margin-bottom: var(--spacing-s);
  font-size: 0.9rem;
}

.status-resting {
  background-color: var(--primary-light);
  color: white;
}

.status-racing {
  background-color: var(--info-color);
  color: white;
}

.status-training {
  background-color: var(--accent-color);
  color: white;
}

.status-injured {
  background-color: var(--danger-color);
  color: white;
}

.status-retired {
  background-color: var(--text-light);
  color: white;
}

.horse-info {
  margin-bottom: var(--spacing-s);
}

.horse-stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: var(--spacing-xs);
  margin-bottom: var(--spacing-s);
}

.stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-xs);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.stat-label {
  font-size: 0.8rem;
  color: var(--text-light);
}

.stat-value {
  font-weight: bold;
}

.horse-condition {
  margin-bottom: var(--spacing-s);
}

.condition-bar {
  display: flex;
  align-items: center;
  gap: var(--spacing-s);
  margin-bottom: var(--spacing-xs);
}

.condition-label {
  font-size: 0.9rem;
  width: 60px;
}

.bar-outer {
  flex: 1;
  height: 8px;
  background-color: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
}

.bar-inner {
  height: 100%;
  background-color: var(--primary-color);
  border-radius: 4px;
}

.condition-value {
  font-size: 0.9rem;
  font-weight: bold;
  width: 40px;
  text-align: right;
}

.horse-value {
  text-align: right;
  font-weight: bold;
  color: var(--secondary-dark);
  margin-bottom: var(--spacing-s);
}

.horse-actions {
  display: flex;
  gap: var(--spacing-s);
}

.horse-actions button {
  flex: 1;
  font-size: 0.9rem;
}

.stable-actions-bottom {
  margin-top: var(--spacing-l);
  text-align: center;
}

.stable-actions-bottom button {
  width: 100%;
  max-width: 300px;
  padding: var(--spacing-m);
}

/* Training Modal */
.training-modal .modal-body {
  padding-bottom: var(--spacing-l);
}

.training-type-selector {
  margin-bottom: var(--spacing-m);
}

.training-intensity-selector {
  margin-bottom: var(--spacing-m);
}

.intensity-slider-container {
  margin-top: var(--spacing-s);
}

.intensity-slider-container input {
  width: 100%;
  margin-bottom: var(--spacing-xs);
}

.intensity-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--text-light);
}

.training-info {
  background-color: #f5f5f5;
  padding: var(--spacing-s);
  border-radius: var(--border-radius-s);
  font-size: 0.9rem;
}

/* Horse Detail Screen */
.horse-detail-container {
  padding-bottom: var(--spacing-xl);
}

.detail-header {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-m);
}

.back-button {
  background: none;
  font-size: 1.5rem;
  padding: 0;
  margin-right: var(--spacing-m);
}

.horse-profile {
  display: flex;
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.horse-avatar {
  width: 100px;
  height: 100px;
  background-color: var(--secondary-light);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.horse-silhouette {
  width: 80%;
  height: 80%;
  background-color: rgba(0, 0, 0, 0.2);
  mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M90,60c-5-10-15-15-25-15s-15,5-20,5s-10-5-15-5s-10,5-15,10S5,65,5,70s5,10,10,10s10-5,15-5s10,5,15,5s10-5,15-5s10,5,15,5s10-5,15-10S95,70,90,60z"/></svg>');
  mask-repeat: no-repeat;
  mask-position: center;
}

.horse-main-stats {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.main-stat {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-xs) 0;
  border-bottom: 1px solid var(--border-color);
}

.stat-value.rating {
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--primary-color);
}

.horse-attributes, .horse-condition-detail, .horse-preferences, 
.racing-history, .pedigree-section, .market-value {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.attribute-grid {
  display: grid;
  gap: var(--spacing-s);
}

.attribute {
  display: flex;
  align-items: center;
  gap: var(--spacing-s);
}

.attribute-label {
  width: 110px;
}

.attribute-bar {
  flex: 1;
  height: 12px;
  background-color: #e0e0e0;
  border-radius: 6px;
  overflow: hidden;
}

.bar-fill {
  height: 100%;
  background-color: var(--primary-color);
  border-radius: 6px;
}

.attribute-value {
  width: 40px;
  text-align: right;
  font-weight: bold;
}

.condition-bars {
  display: grid;
  gap: var(--spacing-s);
}

.condition-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-s);
}

.preferences-grid {
  display: grid;
  gap: var(--spacing-s);
}

.preference {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-xs) 0;
  border-bottom: 1px solid var(--border-color);
}

.history-stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: var(--spacing-s);
  margin-bottom: var(--spacing-m);
}

.history-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--spacing-s);
  background-color: #f5f5f5;
  border-radius: var(--border-radius-s);
}

.race-history-table {
  overflow-x: auto;
}

.race-history-table table {
  width: 100%;
  border-collapse: collapse;
}

.race-history-table th, .race-history-table td {
  padding: var(--spacing-s);
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}

.race-history-table th {
  font-weight: bold;
  color: var(--text-light);
}

.pedigree-info p {
  margin-bottom: var(--spacing-xs);
}

.value-info p {
  margin-bottom: var(--spacing-xs);
}

.horse-actions {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-s);
  margin-top: var(--spacing-l);
}

.horse-actions button {
  flex: 1;
  min-width: 120px;
}

/* Race Screen */
.race-screen-container {
  padding-bottom: var(--spacing-xl);
}

.selected-horse-banner, .no-horse-banner {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
  display: flex;
  flex-direction: column;
  gap: var(--spacing-s);
  align-items: center;
}

.races-list {
  display: grid;
  gap: var(--spacing-m);
}

.race-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  overflow: hidden;
  box-shadow: var(--shadow-small);
}

.race-header {
  padding: var(--spacing-m);
  color: white;
}

.race-header.local {
  background-color: var(--local-race);
}

.race-header.regional {
  background-color: var(--regional-race);
}

.race-header.national {
  background-color: var(--national-race);
}

.race-header.elite {
  background-color: var(--elite-race);
}

.race-header.international {
  background-color: var(--international-race);
}

.race-type {
  font-size: 0.9rem;
  opacity: 0.9;
}

.race-details {
  display: flex;
  padding: var(--spacing-m);
  border-bottom: 1px solid var(--border-color);
}

.race-info, .race-purse {
  flex: 1;
}

.info-label {
  font-weight: bold;
  color: var(--text-light);
}

.race-participants {
  padding: var(--spacing-m);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.race-actions {
  padding: var(--spacing-m);
  display: flex;
  gap: var(--spacing-s);
}

.race-actions button, .already-entered {
  flex: 1;
}

.already-entered {
  text-align: center;
  padding: var(--spacing-s);
  background-color: #e0e0e0;
  border-radius: var(--border-radius-m);
  color: var(--text-light);
}

/* Race Detail Screen */
.race-detail-container {
  padding-bottom: var(--spacing-xl);
}

.race-info-banner {
  background-color: var(--primary-color);
  color: white;
  padding: var(--spacing-m);
  border-radius: var(--border-radius-l);
  margin-bottom: var(--spacing-m);
}

.race-winners {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.winner-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
  position: relative;
  width: 280px;
  text-align: center;
}

.position-badge {
  position: absolute;
  top: -10px;
  left: 50%;
  transform: translateX(-50%);
  padding: var(--spacing-xs) var(--spacing-s);
  border-radius: var(--border-radius-m);
  font-weight: bold;
  box-shadow: var(--shadow-small);
}

.winner-card.first .position-badge {
  background-color: gold;
  color: black;
}

.winner-card.second .position-badge {
  background-color: silver;
  color: black;
}

.winner-card.third .position-badge {
  background-color: #cd7f32; /* bronze */
  color: white;
}

.prize-amount {
  margin-top: var(--spacing-s);
  font-weight: bold;
  color: var(--success-color);
}

.full-results {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
  overflow-x: auto;
}

.results-table {
  width: 100%;
  border-collapse: collapse;
}

.results-table th, .results-table td {
  padding: var(--spacing-s);
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}

.results-table th {
  font-weight: bold;
  color: var(--text-light);
}

.player-horse {
  background-color: rgba(0, 0, 0, 0.05);
}

.player-performance {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.good-result {
  color: var(--success-color);
}

/* Market Screen */
.market-screen-container {
  padding-bottom: var(--spacing-xl);
}

.market-header {
  margin-bottom: var(--spacing-m);
}

.market-stats {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-s);
  margin-top: var(--spacing-xs);
  color: var(--text-light);
  font-size: 0.9rem;
}

.market-controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: var(--spacing-m);
}

.market-horses-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-m);
  margin-bottom: var(--spacing-l);
}

.market-horse-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  box-shadow: var(--shadow-small);
}

.horse-price {
  text-align: right;
  font-weight: bold;
  font-size: 1.2rem;
  color: var(--secondary-dark);
  margin: var(--spacing-s) 0;
}

.market-actions {
  display: flex;
  gap: var(--spacing-s);
}

.empty-market {
  background-color: var(--card-background);
  border-radius: var(--border-radius-l);
  padding: var(--spacing-m);
  margin-bottom: var(--spacing-l);
  box-shadow: var(--shadow-small);
  text-align: center;
}

.player-listings {
  margin-bottom: var(--spacing-l);
}

.listings-grid {
  display: grid;
  grid-template-columns: repeat(auto